///////////////////////////////////////////////////////////////////////////////
// ПЕРЕМЕННЫЕ МОДУЛЯ 

Перем ТекущийФильтрОтбора; // строковое представление текущего фильтра

Перем НомерСтрокиДерева; // текущий номер строки дерева

// Соответствие, ключ - номер строки реквизита "ДеревоСравнения", значение - строка дерева значений.
Перем СоответствиеНомеровСтрокДерева;	
										
// Структура, ключ - имя справочника, значение - таблица значений, с перечнем реквизитов,
// участвующих в сравнении.
Перем СравниваемыеРеквизиты;							

Перем ПримитивныеТипы; // массив примитивных типов
Перем ПоддерживаемыеТипы; // массив типов, которые допускается модифицировать программно

//Соответствие, ключ - ссылка на справочник "Конвертации", значение - номер строки табличной части "Конвертации".
Перем СоответствияПравил;						

///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБЩЕГО НАЗНАЧЕНИЯ

// Выполняет восстановление булевых значений реквизитов формы.
//
// Параметры:
//  Значение - Произвольный - реквизит формы.
//  ИмяВосстановления - Строка - имя сохраненного значения.
//  ЗначениеПоУмолчанию - Булево - значение по умолчанию.
//
Процедура ВосстановитьЗначениеБулево(Значение, ИмяВосстановления, ЗначениеПоУмолчанию = Истина)
	
	ЗначениеЭлемента = ВосстановитьЗначение(ИмяВосстановления);
	
	Если ЗначениеЭлемента = Неопределено Тогда 
		
		Значение = ЗначениеПоУмолчанию;
		
	Иначе
		
		Значение = ЗначениеЭлемента;
		
	КонецЕсли;
	
КонецПроцедуры // ВосстановитьЗначениеБулево()

// Выполняет проверку того, что правила конвертации, выбранные в последний раз существуют в справочнике "Конвертации".
//
Процедура ПроверитьАктуальностьПравилОбмена() 
	
	НеактуальныеСтроки = Новый Массив;
	
	Для каждого СтрокаТабличнойЧасти Из Конвертации Цикл
		
		Если НЕ ОбъектБазыДанныхСуществует(СтрокаТабличнойЧасти.Конвертация) Тогда
			
			НеактуальныеСтроки.Добавить(СтрокаТабличнойЧасти);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Для каждого Строка Из НеактуальныеСтроки Цикл
		
		Конвертации.Удалить(Строка);
		
	КонецЦикла;
	
КонецПроцедуры // ПроверитьАктуальностьПравилОбмена() 

// Заполняет табличную часть "РеквизитыСравнения" реквизитами справочников конфигурации.
// Последовательность заполнения:
//  - последовательно обходятся реквизиты справочников конфигурации, участвующие в сравнении
//  и имена их реквизитов переносятся в табличную часть "РеквизитыСравнения".
//  - восстанавливаются данные табличной части, сохраненные в предыдущем сеансе и производится
//  снятие пометок, которые были сняты ранее.
//
Процедура ЗаполнитьТаблицуРеквизитовСравнения() 
	
	МассивСправочники = Новый Массив;
	МассивСправочники.Добавить("Конвертации");
	МассивСправочники.Добавить("Параметры");
	МассивСправочники.Добавить("ПравилаКонвертацииОбъектов");
	МассивСправочники.Добавить("ПравилаКонвертацииСвойств");
	МассивСправочники.Добавить("ПравилаВыгрузкиДанных");
	МассивСправочники.Добавить("ПравилаОчисткиДанных");
	МассивСправочники.Добавить("Алгоритмы");
	МассивСправочники.Добавить("Запросы");

	Для каждого Элемент Из МассивСправочники Цикл
		
		Для каждого РеквизитСправочника Из Метаданные.Справочники[Элемент].Реквизиты Цикл
			
			Если НЕ СравниватьПорядокВыполнения Тогда
				
				Если РеквизитСправочника.Имя = "Порядок" Тогда
					
					Продолжить;
					
				КонецЕсли;
				
			КонецЕсли;
			
			Если (Элемент = "Алгоритмы" И РеквизитСправочника.Имя = "Алгоритм") 
				ИЛИ (Элемент = "Запросы" И РеквизитСправочника.Имя = "ТекстЗапроса") Тогда
				
				Продолжить;
				
			КонецЕсли;					
			
			НоваяСтрока = РеквизитыСравнения.Добавить();
			
			НоваяСтрока.Справочник	= Элемент;
			НоваяСтрока.Реквизит	= РеквизитСправочника.Имя;
			НоваяСтрока.Пометка		= Истина;
			
		КонецЦикла;
		
	КонецЦикла;
	
	ТаблицаРеквизитов = ВосстановитьЗначение("СравнениеИОбъединениеПравилОбмена.РеквизитыСравнения");  
	
	// Снимем пометки со строк, сохраненных в предыдущем сеансе.
	
	Если ТипЗнч(ТаблицаРеквизитов) = Тип("ТаблицаЗначений") Тогда
		
		СтруктураОтбора = Новый Структура("Пометка", Ложь);
		
		СтрокиТаблицыРеквизитов = ТаблицаРеквизитов.НайтиСтроки(СтруктураОтбора);
		
		Для каждого СтрокаТаблицы Из СтрокиТаблицыРеквизитов Цикл
			
			СтруктураОтбора = Новый Структура("Справочник,Реквизит");
			
			ЗаполнитьЗначенияСвойств(СтруктураОтбора, СтрокаТаблицы);
			
			СтрокиТабличнойЧасти = РеквизитыСравнения.НайтиСтроки(СтруктураОтбора);
			
			Для каждого СтрокаТабличнойЧасти Из СтрокиТабличнойЧасти Цикл
				
				СтрокаТабличнойЧасти.Пометка = Ложь;
				
			КонецЦикла;
			
		 КонецЦикла;
		
	КонецЕсли;  
	
КонецПроцедуры // ЗаполнитьТаблицуРеквизитовСравнения()

// Выполняет удаление строк дерева значений, переданных в массиве.
//
// Параметры:
//  ДеревоЗначений - ДеревоЗначений - исходное дерево, из которого необходимо
//                   удалить переданные строки.
//  МассивСтрок - Массив - массив строк дерева значений.
//
Процедура УдалитьСтрокиДереваВМассиве(ДеревоЗначений, МассивСтрок)
	
	ТаблицаСтрок = Новый ТаблицаЗначений;
	ТаблицаСтрок.Колонки.Добавить("СтрокаДерева");
	ТаблицаСтрок.Колонки.Добавить("НомерСтрокиДерева");
	
	Для каждого СтрокаДерева Из МассивСтрок Цикл
		
		НоваяСтрока = ТаблицаСтрок.Добавить();
		НоваяСтрока.СтрокаДерева = СтрокаДерева;
		НоваяСтрока.НомерСтрокиДерева = СтрокаДерева.НомерСтроки;
		
	КонецЦикла;
	
	ТаблицаСтрок.Сортировать("НомерСтрокиДерева Убыв");
	
	Для каждого СтрокаТаблицы Из ТаблицаСтрок Цикл
		
		Родитель = СтрокаТаблицы.СтрокаДерева.Родитель;
		
		Если Родитель = Неопределено Тогда
			
			ДеревоЗначений.Строки.Удалить(СтрокаТаблицы.СтрокаДерева);
			
		Иначе
			
			Родитель.Строки.Удалить(СтрокаТаблицы.СтрокаДерева);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // УдалитьСтрокиДереваВМассиве()

// Выполняет удаление кнопки командной панели формы.
// 
// Параметры:
//  ИмяКнопки - Строка - имя кнопки, которую необходимо удалить
//  КоманднаяПанель - Строка - имя командной панели формы.
//
Процедура УдалитьКнопкуКоманднойПанели(ИмяКнопки, КоманднаяПанель = "КонтекстноеМеню")
	
	Кнопка = ЭлементыФормы[КоманднаяПанель].Кнопки.Найти(ИмяКнопки);
	
	Если Кнопка <> Неопределено Тогда
		
		ЭлементыФормы[КоманднаяПанель].Кнопки.Удалить(Кнопка);
		
	КонецЕсли;
	
КонецПроцедуры // УдалитьКнопкуКоманднойПанели()

// Выполняет добавление кнопки командной панели формы.
//
// Параметры:
//  ИмяКнопки - Строка - имя кнопки командной панели формы, которую необходимо добавить.
//  КоманднаяПанель - Строка - имя командной панели формы.
//  Представление - Строка - представление добавляемой кнопки.
//  ТипКнопки - Тип кнопки командной панели.
//  Действие - Действие.
//  Картинка - Картинка - картинка кнопки.
//
Процедура ДобавитьКнопкуКоманднойПанели(ИмяКнопки, КоманднаяПанель = "КонтекстноеМеню",
	Представление = "", ТипКнопки, Действие = "", Картинка = Неопределено)
	
	Если ТипКнопки = ТипКнопкиКоманднойПанели.Подменю 
		ИЛИ ТипКнопки = ТипКнопкиКоманднойПанели.Разделитель Тогда
		
		ЭлементыФормы[КоманднаяПанель].Кнопки.Добавить(ИмяКнопки, ТипКнопки, Представление);
		
	Иначе
		
		ЭлементыФормы[КоманднаяПанель].Кнопки.Добавить(ИмяКнопки, ТипКнопки, Представление, Действие);
		
	КонецЕсли;
	
	Если Картинка <> Неопределено Тогда
		
		ЭлементыФормы[КоманднаяПанель].Кнопки[ИмяКнопки].Картинка = Картинка;
		
	КонецЕсли;
	
КонецПроцедуры // ДобавитьКнопкуКоманднойПанели()

// Выполняет очистку содержимого строки от всех символов, кроме цифр.
//
// Параметры:
//  ПреобразуемаяСтрока - Строка - строка, которую необходимо преобразовать.
//  ПреобразоватьВЧисло - Булево - признак необходимости преобразовать очищенную
//                        строку в число.
//
// Возвращаемое значение:
//  Результат - Число или Строка - значение, очищенное от прочих символов, кроме цифр. 
//
Функция ОставитьТолькоЦифры(Знач ПреобразуемаяСтрока, ПреобразоватьВЧисло = Ложь)
	
	Результат = "";
	
	Для Ном = 1 По СтрДлина(ПреобразуемаяСтрока) Цикл
		
		Значение = Сред(ПреобразуемаяСтрока, Ном, 1);
		
		КодСимвола = КодСимвола(Значение);
		
		Если (КодСимвола >= 48 И КодСимвола <= 57) Тогда
			
			Результат = Результат + Значение;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если ПреобразоватьВЧисло Тогда
		
		Попытка
			Результат = Число(Результат);
		Исключение
			Результат = 0;
		КонецПопытки;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ОставитьТолькоЦифры()

// Выполняет сворачивание (разворачивание) строк дерева значений, подчиненных текущей строке.
//
// Параметры:
//  СтрокаДерева - Строка дерева значений - текущая строка дерева.
//  Сворачивать - Булево - признак вида операции.
//
Процедура РазвернутьСвернутьСтрокуДерева(СтрокаДерева, Сворачивать = Ложь)
	
	Если Сворачивать Тогда
		
		ЭлементыФормы.ДеревоРезультатСравнения.Свернуть(СтрокаДерева);
		
	Иначе
		
		ЭлементыФормы.ДеревоРезультатСравнения.Развернуть(СтрокаДерева);
		
	КонецЕсли;
	
	Для каждого СтрокаПодчиненная Из СтрокаДерева.Строки Цикл
		
		РазвернутьСвернутьСтрокуДерева(СтрокаПодчиненная, Сворачивать);
		
	КонецЦикла;
	
КонецПроцедуры // РазвернутьСвернутьСтрокуДерева() 

// Получает массив подчиненных строк дерева значений.
//
// Параметры:
//  СтрокаДерева - Дерево значений, строка дерева значений - строка
//                 дерева значений или дерево значений, строки которого
//                 необходимо получить.
//  МассивСтрок - Массив - массив подчиненных строк дерева значений.
//
Процедура ПолучитьПодчиненныеСтрокиДереваЗначений(СтрокаДерева, МассивСтрок)
	
	Если ТипЗнч(СтрокаДерева) = Тип("СтрокаДереваЗначений") Тогда
	
		МассивСтрок.Добавить(СтрокаДерева);
	
	КонецЕсли;
	
	Для каждого ПодчиненнаяСтрока Из СтрокаДерева.Строки Цикл
		
		ПолучитьПодчиненныеСтрокиДереваЗначений(ПодчиненнаяСтрока, МассивСтрок);
		
	КонецЦикла;
	
КонецПроцедуры // ПолучитьПодчиненныеСтрокиДереваЗначений()

// Выполняет изменение ключевых колонок сравнения - пометка, различий и флагов различий.
//
// Параметры:
//  СтрокиДерева - Массив - массив строк дерева значений, которые должны быть обработаны.
//  Различия - Число - значение колонок "Различия...".
//  ЕстьРазличия - Булево - значение колонок "ЕстьРазличия...".
//
Процедура ИзменитьЗначенияРеквизитовСтрокиДерева(СтрокиДерева, Различия, ЕстьРазличия)
	
	СтруктураЗаполнения = Новый Структура;
	
	КоличествоКолонок = Конвертации.Количество() - 1;
	
	Для Ном = 1 По КоличествоКолонок Цикл
		
		СтруктураЗаполнения.Вставить("Различия" + Ном, Различия);
		СтруктураЗаполнения.Вставить("ЕстьРазличия" + Ном, ЕстьРазличия);
		
	КонецЦикла;
	
	Для каждого СтрокаДерева Из СтрокиДерева Цикл
		
		ЗаполнитьЗначенияСвойств(СтрокаДерева, СтруктураЗаполнения);
		
	КонецЦикла;
	
КонецПроцедуры // ИзменитьЗначенияРеквизитовСтрокиДерева()

// Устанавливает фильтры отбора к дереву значений.
//
// Параметры:
//  ДеревоЗначений - Дерево значений - дерево значений к которому должны быть применены фильтры.
//  СтрокаДерева - Строка дерева значений - текущая строка дерева значений или дерево значений,
//                 в подчиненных строках которого необходимо установить отборы.
//
Процедура ПрименитьЗначениеФильтраОтбора(ДеревоЗначений, СтрокаДерева)
	
	КоличествоКолонокРазличий = Конвертации.Количество() - 1;
	
	ИсходнаяСтрокаУдалена = Ложь;
	
	Если ФильтрОтбора > 0 Тогда
		
		СтруктураОтбор = НовыйСтруктураКолонок("ЕстьРазличия", Конвертации.Количество() - 1, Ложь);
		
		НеизмененныеСтроки = СтрокаДерева.Строки.НайтиСтроки(СтруктураОтбор, Истина);
		
		ИсходнаяСтрокаУдалена = НеизмененныеСтроки.Найти(СтрокаДерева) <> Неопределено;
		
		УдалитьСтрокиДереваВМассиве(ДеревоЗначений, НеизмененныеСтроки);
		
	КонецЕсли;
		
	Если ФильтрОтбора = 2 И НЕ ИсходнаяСтрокаУдалена Тогда
		
		МассивСтрок = Новый Массив;
		
		ПолучитьПодчиненныеСтрокиДереваЗначений(СтрокаДерева, МассивСтрок);
		
		ДеревоЗначений.Колонки.Добавить("ИзмененСостав", Новый ОписаниеТипов("Булево"));
		
		Для каждого СтрокаДереваЗначений Из МассивСтрок Цикл
			
			Для Ном = 1 По КоличествоКолонокРазличий Цикл
				
				ИмяКолонки = "Различия" + Ном;
				
				Если СтрокаДереваЗначений[ИмяКолонки] < 0 ИЛИ СтрокаДереваЗначений[ИмяКолонки] = 1 Тогда
					
					СтрокаДереваЗначений.ИзмененСостав = Истина;
					
					УстановитьРазличияРодителя(СтрокаДереваЗначений, "ИзмененСостав");
					
					Прервать;
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
		СтруктураОтбор = Новый Структура("ИзмененСостав", Ложь);
		
		СтрокиБезИзменений = СтрокаДерева.Строки.НайтиСтроки(СтруктураОтбор, Истина);
		
		УдалитьСтрокиДереваВМассиве(ДеревоЗначений, СтрокиБезИзменений); 
		
		ДеревоЗначений.Колонки.Удалить(ДеревоЗначений.Колонки.Найти("ИзмененСостав"));
		
		УстановитьФлажкиДерева(ДеревоЗначений);
		
	КонецЕсли;
	
КонецПроцедуры // ПрименитьЗначениеФильтраОтбора()

// Добавляет кнопки командной панели "КонтекстноеМеню" для сравнения модулей выгрузки 
// и модулей загрузки правил обмена, разработанных на платформе 1С:Предприятие 7.7.
//
// Параметры:
//  ЛевоеЗначение - СправочникСсылка.Конвертации - левое сравниваемое значение.
//  ПравоеЗначение - СправочникСсылка.Конвертации - правое сравниваемое значение.
//  Направление - Строка - направление сравнения.
//  ПоказатьНаправление - Булево - признак необходимости показа в наименовании кнопки
//                        направления сравнения.
//
Процедура ДобавитьКнопкиСравненияМодулейВыгрузкиЗагрузки(ЛевоеЗначение, ПравоеЗначение,
	Направление, ПоказатьНаправление = Ложь)
	
	Если ТипЗнч(ЛевоеЗначение) = Тип("СправочникСсылка.Конвертации") 
		И ТипЗнч(ПравоеЗначение) = Тип("СправочникСсылка.Конвертации") Тогда
		
		НаправлениеТекст =  ?(ПоказатьНаправление, " (" + НРег(Направление) + ")", "");
		
		Если ЛевоеЗначение.Источник.Приложение = Перечисления.Приложения.Предприятие77
			И ПравоеЗначение.Источник.Приложение = Перечисления.Приложения.Предприятие77 Тогда
			
			ТекстКнопки = НСтр("ru = 'Сравнить модули выгрузки %Направление%'");
			ТекстКнопки = СтрЗаменить(ТекстКнопки, "%Направление%", НаправлениеТекст);
			
			ДобавитьКнопкуКоманднойПанели("СравнитьМодулиВыгрузки" + Направление,, ТекстКнопки, ТипКнопкиКоманднойПанели.Действие,
				Новый Действие("Подключаемый_КонтекстноеМенюСравнитьМодулиВыгрузки" + Направление), БиблиотекаКартинок.ПоказатьРазличия);
			
			КонецЕсли;
			
			Если ЛевоеЗначение.Приемник.Приложение = Перечисления.Приложения.Предприятие77
				И ПравоеЗначение.Приемник.Приложение = Перечисления.Приложения.Предприятие77 Тогда
				
				ТекстКнопки = НСтр("ru = 'Сравнить модули загрузки %Направление%'");
				ТекстКнопки = СтрЗаменить(ТекстКнопки, "%Направление%", НаправлениеТекст); 
				
				ДобавитьКнопкуКоманднойПанели("СравнитьМодулиЗагрузки" + Направление,, ТекстКнопки, ТипКнопкиКоманднойПанели.Действие,
				Новый Действие("Подключаемый_КонтекстноеМенюСравнитьМодулиЗагрузки" + Направление), БиблиотекаКартинок.ПоказатьРазличия);
				
			КонецЕсли;
			
		КонецЕсли;
		
КонецПроцедуры // ДобавитьКнопкиСравненияМодулейВыгрузкиЗагрузки()

// Выполняет обновление кнопок командной панели "КонтекстноеМеню" в зависимости
// от данных, содержащихся в текущей строкие дерева значений.
//
Процедура ДеревоРезультатСравненияОбновитьКонтекстноеМеню()
	
	// Удалим кнопки контекстного меню.
	
	УдалитьКнопкуКоманднойПанели("Разделитель2");
	УдалитьКнопкуКоманднойПанели("ВзятьИзЛевого");
	УдалитьКнопкуКоманднойПанели("ВзятьИзПравого");
	УдалитьКнопкуКоманднойПанели("ОбъединитьСЛевым");
	УдалитьКнопкуКоманднойПанели("ОбъединитьСПравым");
	
	ТекущиеДанные = ЭлементыФормы.ДеревоРезультатСравнения.ТекущиеДанные;
	
	Если ТекущиеДанные = Неопределено Тогда
		
		Возврат;
		
	КонецЕсли;
	
	ТекущаяКолонка = ЭлементыФормы.ДеревоРезультатСравнения.ТекущаяКолонка;
	
	Если Найти(ТекущаяКолонка.Имя, "Колонка") = 0 Тогда
		
		Возврат;
		
	КонецЕсли;
	
	НомерКолонки = ОставитьТолькоЦифры(ТекущаяКолонка.Имя, Истина);
	
	// Добавим новые кнопки контекстного меню.
	
	Если НомерКолонки = 1 Тогда
		
		ДобавитьКнопкуКоманднойПанели("Разделитель2",,, ТипКнопкиКоманднойПанели.Разделитель);
		
		ДобавитьКнопкиОбъединенияПравил(ТекущиеДанные, НомерКолонки, 0, 1);
		
	ИначеЕсли НомерКолонки = Конвертации.Количество() Тогда
		
		ДобавитьКнопкуКоманднойПанели("Разделитель2",,, ТипКнопкиКоманднойПанели.Разделитель);
		
		ДобавитьКнопкиОбъединенияПравил(ТекущиеДанные, НомерКолонки, -1, 0);
		
	Иначе
		
		ДобавитьКнопкуКоманднойПанели("Разделитель2",,, ТипКнопкиКоманднойПанели.Разделитель);
		
		ДобавитьКнопкиОбъединенияПравил(ТекущиеДанные, НомерКолонки, -1, 0);
		ДобавитьКнопкиОбъединенияПравил(ТекущиеДанные, НомерКолонки, 0, 1);
		
	КонецЕсли;
	
КонецПроцедуры // ДеревоРезультатСравненияОбновитьКонтекстноеМеню()

// Добавляет кнопки командной панели "КонтекстноеМеню", содержащие команды объединения правил обмена.
//
// Параметры:
//  ТекущиеДанные - Строка дерева значений.
//  НомерКолонки - Число - номер текущей колонки.
//  ЛеваяКолонка - Число - расположение левой колонки относительно текущей.
//  ПраваяКолонка - Число - расположение правой колонки относительно текущей.
//
Процедура ДобавитьКнопкиОбъединенияПравил(ТекущиеДанные, НомерКолонки, ЛеваяКолонка, ПраваяКолонка)
	
	Если ТекущиеДанные.Пометка = 0 Тогда
		
		Возврат;
		
	КонецЕсли;
	
	Если НЕ Конвертации[НомерКолонки - 1].Пометка Тогда
		
		Возврат;
		
	КонецЕсли;
	
	ЛевоеЗначение	= ТекущиеДанные["Колонка" + (НомерКолонки + ЛеваяКолонка)];
	ПравоеЗначение	= ТекущиеДанные["Колонка" + (НомерКолонки + ПраваяКолонка)];
	
	ДопустимыеГруппы = Новый Массив;
	ДопустимыеГруппы.Добавить("РазделПКО");
	ДопустимыеГруппы.Добавить("РазделПВД");
	ДопустимыеГруппы.Добавить("РазделПОД");
	ДопустимыеГруппы.Добавить("РазделАлгоритмы");
	ДопустимыеГруппы.Добавить("РазделЗапросы");
	ДопустимыеГруппы.Добавить("ГруппаПараметры");
	
	Если ПоддерживаемыеТипы.Найти(ТипЗнч(ЛевоеЗначение)) <> Неопределено
		ИЛИ ПоддерживаемыеТипы.Найти(ТипЗнч(ПравоеЗначение)) <> Неопределено 		
		ИЛИ (ДопустимыеГруппы.Найти(ТекущиеДанные.Путь) <> Неопределено
		ИЛИ ДопустимыеГруппы.Найти(ТекущиеДанные.Путь) <> Неопределено) Тогда
		
		Если ЛеваяКолонка < 0 Тогда
			
			ДобавитьКнопкуКоманднойПанели("ВзятьИзЛевого",, Нстр("ru = 'Выполнить объединение'"), ТипКнопкиКоманднойПанели.Действие,
				Новый Действие("Подключаемый_КонтекстноеМенюВзятьИзЛевогоНажатие"));
			
		Иначе
			
			ДобавитьКнопкуКоманднойПанели("ВзятьИзПравого",, Нстр("ru = 'Выполнить объединение'"), ТипКнопкиКоманднойПанели.Действие,
				Новый Действие("Подключаемый_КонтекстноеМенюВзятьИзПравогоНажатие"));
			
		КонецЕсли;
		
	КонецЕсли;
				
	Если ИспользоватьKDiff3ДляОбъединенияМодулей 
		И ТекущиеДанные.ВозможноОбъединение		
		И ЗначениеЗаполнено(ЛевоеЗначение) 
		И ЗначениеЗаполнено(ПравоеЗначение) Тогда
		
		ТекстКнопки = НСтр("ru = 'Объединить правила с помощью KDiff3 %Направление%'");
		
		Если ЛеваяКолонка < 0 Тогда
			
			НаправлениеТекст = ?(НомерКолонки < Конвертации.Количество(), "с левым", "");
			
			ТекстКнопки = СтрЗаменить(ТекстКнопки, "%Направление%", НаправлениеТекст);
			
			ДобавитьКнопкуКоманднойПанели("ОбъединитьСЛевым",, ТекстКнопки, ТипКнопкиКоманднойПанели.Действие,
				Новый Действие("Подключаемый_КонтекстноеМенюОбъединитьСЛевымНажатие"));
			
		ИначеЕсли ПраваяКолонка > 0 Тогда
			
			НаправлениеТекст = ?(НомерКолонки > 1, "с правым", "");
			
			ТекстКнопки = СтрЗаменить(ТекстКнопки, "%Направление%", НаправлениеТекст);
			
			ДобавитьКнопкуКоманднойПанели("ОбъединитьСПравым",, ТекстКнопки, ТипКнопкиКоманднойПанели.Действие,
				Новый Действие("Подключаемый_КонтекстноеМенюОбъединитьСПравымНажатие"));
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры // ДобавитьКнопкуОбъединенияПравил()

// Выполняет установку флага различия в родительских строках дерева значений.
//
// Параметры:
//  СтрокаДерева - Строка дерева значений - строка дерева значений,
//                 в родительских строках которой должно быть изменено
//                 значение флага изменений.
//  ИмяКолонки - Строка - имя колонки в которой изменяется значений флага.
//
Процедура УстановитьРазличияРодителя(СтрокаДерева, ИмяКолонки) 
	
	Пока СтрокаДерева.Родитель <> Неопределено Цикл
		
		СтрокаДерева.Родитель[ИмяКолонки] = СтрокаДерева[ИмяКолонки];
		
		СтрокаДерева = СтрокаДерева.Родитель;
		
	КонецЦикла;
	
КонецПроцедуры // УстановитьРазличияРодителя()

// Выполняет поиск строк дерева с признаком наличия изменений и вызывает установку
// признака различия в родительских строках.
//
// Параметры:
//  Дерево - Дерево значений - дерево значений для которого выполняется поиск и установка различий.
//
Процедура УстановитьРазличияСтрок(Дерево) 
	
	КоличествоКолонок = Конвертации.Количество() - 1;
	
	Для Ном = 1 По КоличествоКолонок Цикл
		
		ИмяКолонки = "ЕстьРазличия" + Ном;
		
		СтруктураОтбор = Новый Структура(ИмяКолонки, Истина);
		
		ОтмеченныеСтроки = Дерево.Строки.НайтиСтроки(СтруктураОтбор, Истина);
		
		Для каждого Строка Из ОтмеченныеСтроки Цикл 
			
			УстановитьРазличияРодителя(Строка, ИмяКолонки);
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры // УстановитьРазличияСтрок()

// Выполняет рекурсивный поиск различий в переданной строке дерева значений.
//
// Параметры:
//  СтрокаДерева - Строка дерева значений - строка дерева значений, в которой
//                 и подчиненных строках которой будет выполняться поиск различий.
//
Процедура НайтиОтличияВСтрокеДерева(СтрокаДерева)
	
	РодительскаяСтрока = СтрокаДерева.Родитель;
	
	Если РодительскаяСтрока = Неопределено Тогда
		
		СформироватьДеревоРезультатСравнения();
		
	Иначе
		
		ПодчиненныеСтроки = Новый Массив;
		
		ПолучитьПодчиненныеСтрокиДереваЗначений(СтрокаДерева, ПодчиненныеСтроки);
		
		ИзменитьЗначенияРеквизитовСтрокиДерева(ПодчиненныеСтроки, 0, Ложь);
		
		УстановитьРазличияСтрок(СтрокаДерева);
		
		ВыполнитьАнализСтрокиДерева(СтрокаДерева);
		
		УстановитьФлажкиДерева(СтрокаДерева);
		
		УстановитьРазличияСтрок(СтрокаДерева);
		
		ПрименитьЗначениеФильтраКТекущейСтрокеДерева(ДеревоРезультатСравнения, СтрокаДерева);
		
	КонецЕсли;
	
КонецПроцедуры // НайтиОтличияВСтрокеДерева()

// Создает структуру с именами колонок дерева значений.
//
// Параметры:
//  ИмяКолонки - Строка - имя колонки
//
// Возвращаемое значение:
//  СтруктураКолонок - Структура - в ключах которой содержатся имена колонок.
//
Функция НовыйСтруктураКолонок(ИмяКолонки, КоличествоКолонок, Значение = Неопределено)
	
	СтруктураКолонок = Новый Структура;
	
	Для Ном = 1 По КоличествоКолонок Цикл
		
		КолонкаИмя = ИмяКолонки + Ном;
		
		СтруктураКолонок.Вставить(КолонкаИмя, Значение);
		
	КонецЦикла; 
	
	Возврат СтруктураКолонок;
	
КонецФункции // НовыйСтруктураКолонок() 

// Выполняет открытие формы настройки и передает в нее параметры обработки.
//
// Параметры:
//  ВариантНастройки - Строка - определяет значение параметра формы "ФормаНастройки".
//
Процедура ОткрытьФормуНастройки(ВариантНастройки) 
	
	ПараметрыНастройки = Новый Структура;
	ПараметрыНастройки.Вставить("СравниватьОбщие"							, СравниватьОбщие);
	ПараметрыНастройки.Вставить("СравниватьПравилаКонвертацииОбъектов"		, СравниватьПравилаКонвертацииОбъектов);
	ПараметрыНастройки.Вставить("СравниватьПравилаКонвертацииСвойств"		, СравниватьПравилаКонвертацииСвойств);
	ПараметрыНастройки.Вставить("СравниватьПравилаКонвертацииСвойствПоКоду"	, СравниватьПравилаКонвертацииСвойствПоКоду);
	ПараметрыНастройки.Вставить("СравниватьПравилаКонвертацииЗначений"		, СравниватьПравилаКонвертацииЗначений);
	ПараметрыНастройки.Вставить("СравниватьПравилаВыгрузкиДанных"			, СравниватьПравилаВыгрузкиДанных);
	ПараметрыНастройки.Вставить("СравниватьПравилаОчисткиДанных"			, СравниватьПравилаОчисткиДанных);
	ПараметрыНастройки.Вставить("СравниватьАлгоритмы"						, СравниватьАлгоритмы);
	ПараметрыНастройки.Вставить("СравниватьЗапросы"							, СравниватьЗапросы);
	ПараметрыНастройки.Вставить("СравниватьСсылкиПоПредставлению"			, СравниватьСсылкиПоПредставлению);
	ПараметрыНастройки.Вставить("СравниватьПомеченныеНаУдаление"			, СравниватьПомеченныеНаУдаление); 
	ПараметрыНастройки.Вставить("СравниватьПорядокВыполнения"				, СравниватьПорядокВыполнения);
	ПараметрыНастройки.Вставить("ОпределятьТипКартинкиПоИсточнику"			, ОпределятьТипКартинкиПоИсточнику);
	ПараметрыНастройки.Вставить("ТребоватьПодтвержденияПередОбъединением"	, ТребоватьПодтвержденияПередОбъединением);
	ПараметрыНастройки.Вставить("ИспользоватьKDiff3ДляОбъединенияМодулей"	, ИспользоватьKDiff3ДляОбъединенияМодулей);
	ПараметрыНастройки.Вставить("ИсполняемыйФайлKDiff3"						, ИсполняемыйФайлKDiff3); 	
	
	ФормаНастройки = ПолучитьФорму("ФормаНастройки", ЭтаФорма);
	
	ФормаНастройки.ПравилаОбмена		= Конвертации.Выгрузить();
	ФормаНастройки.ТекущаяНастройка		= ВариантНастройки;
	ФормаНастройки.ТекущиеПараметры		= ПараметрыНастройки;
	ФормаНастройки.ТаблицаРеквизитов	= РеквизитыСравнения.Выгрузить();
	
	ФормаНастройки.Открыть();
	
КонецПроцедуры // ОткрытьФормуНастройки()

// Выполняет управление видимостью и доступностью элементов формы в зависимости
// от произведенных настроек.
//
Процедура УстановитьВидимость()
	
	Если ИспользоватьПодвалДляАнализа Тогда
		
		ЭлементыФормы.ПанельПолосыРегулирования.Свертка = РежимСверткиЭлементаУправления.Нет;
		
		ЭлементыФормы.ДеревоРезультатСравнения.Подвал = ВысотаПодвала > 0;
		
		Если ЭлементыФормы.ДеревоРезультатСравнения.Подвал Тогда
			
			ЭлементыФормы.ДеревоРезультатСравнения.ВысотаПодвала = ВысотаПодвала;
			
		КонецЕсли;
		
	Иначе
		
		ЭлементыФормы.ПанельПолосыРегулирования.Свертка = РежимСверткиЭлементаУправления.Лево;
		
		ЭлементыФормы.ДеревоРезультатСравнения.Подвал = Ложь;
		
	КонецЕсли;
	
	ПравилаОбменаТекст = "";
	
	Для Каждого СтрокаТабличнойЧасти Из Конвертации Цикл
		
		Если ОбъектБазыДанныхСуществует(СтрокаТабличнойЧасти.Конвертация) Тогда
			
			ПравилаОбменаТекст = ПравилаОбменаТекст + ?(ПустаяСтрока(ПравилаОбменаТекст), "", ", ")
				+ СтрокаТабличнойЧасти.Конвертация;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ПравилаОбмена = ПравилаОбменаТекст;
	
	Если Конвертации.Количество() <= 1 Тогда
		
		ЭлементыФормы.ПравилаОбмена.ОтметкаНезаполненного = Истина;
		
	КонецЕсли;
	
	ЭлементыФормы.ОсновныеДействияФормы.Кнопки.Действия.Кнопки.Подвал.Пометка = ИспользоватьПодвалДляАнализа;
	
КонецПроцедуры // УстановитьВидимость()

// Выполняет проверку необходимых условий для проведения объединения правил.
// 
// Возвращаемое значение:
//  ПроверкаВыполнена - Булево - признак успешности проведения проверки.
//
Функция ОбъединениеПодтверждено()
	
	ТекущиеДанные = ЭлементыФормы.ДеревоРезультатСравнения.ТекущиеДанные;
	
	Если ТекущиеДанные = Неопределено Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	ТекущаяКолонка = ЭлементыФормы.ДеревоРезультатСравнения.ТекущаяКолонка;
	
	Если Найти(ТекущаяКолонка.Имя, "Колонка") = 0 Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Если ТребоватьПодтвержденияПередОбъединением Тогда
		
		Ответ = Вопрос(НСтр("ru = 'Выполнить объединение объектов?'"), РежимДиалогаВопрос.ДаНет,, КодВозвратаДиалога.Да);
		
		Если Ответ = КодВозвратаДиалога.Нет Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЕсли; 
	
	Возврат Истина;
	
КонецФункции // ОбъединениеПодтверждено()

// Выполняет объединение текстовых реквизитов справочников, являющихся
// обработчиками с помощью программы KDiff3.
// 
// Параметры:
//  ЗначениеПриемник - Строка - значение - приемник.
//  ЗначениеИсточник - Строка - значение - источник.
//
// Возвращаемое значение:
//  ПолученныйТекст - Строка - результат объединения алгоритмов.
//
Функция ОбъединитьСПомощьюKDiff3(ЗначениеПриемник, ЗначениеИсточник)
	
	Если НЕ ЗначениеЗаполнено(ЗначениеПриемник) Тогда
		
		Возврат ЗначениеИсточник;
		
	КонецЕсли;
	
	ВремКаталог = КаталогВременныхФайлов();
	
	ИмяФайлаПриемника = ВремКаталог + "first.txt";
	ИмяФайлаИсточника = ВремКаталог + "second.txt";
	
	ФайлПриемник = Новый ТекстовыйДокумент;
	ФайлИсточник = Новый ТекстовыйДокумент;   
	
	ФайлПриемник.УстановитьТекст(ЗначениеПриемник);
	ФайлИсточник.УстановитьТекст(ЗначениеИсточник); 
	
	ФайлПриемник.Записать(ИмяФайлаПриемника);
	ФайлИсточник.Записать(ИмяФайлаИсточника);
	
	ЗапуститьПриложение(ИсполняемыйФайлKDiff3 + " " + ИмяФайлаПриемника + " " + ИмяФайлаИсточника + " -o result.txt",
		ВремКаталог, Истина);
	
	ИмяФайла = ВремКаталог + "result.txt";
	
	Файл = Новый Файл(ИмяФайла);
	
	Если Файл.Существует() Тогда
		
		РезультатОбъединения = Новый ТекстовыйДокумент;
		РезультатОбъединения.Прочитать(ИмяФайла);
		
		ПолученныйТекст	= РезультатОбъединения.ПолучитьТекст();
		
		Возврат ПолученныйТекст;
		
	Иначе
		
		Возврат ЗначениеПриемник;
		
	КонецЕсли;	
		
КонецФункции // ОбъединитьСПомощьюKDiff3() 

// Рекурсивно выводит строки дерева значений в табличный документ.
//
Процедура ВывестиСтрокиРекурсивно(Уровень, ТабличныйДокумент, ОбластьНачалоСтроки, ОбластьГруппа, ОбластьСтрока, СтрокаДерева)
	
	ЕстьПодчиненные = СтрокаДерева.Строки.Количество() > 0;  
	ЗначениеОтсутствует = Ложь;
	
	ТабличныйДокумент.Вывести(ОбластьНачалоСтроки, Уровень,, Ложь);  
	
	Для Ном = 1 По Конвертации.Количество() Цикл 		
		
		Значение = СтрокаДерева["Колонка" + Ном];		
		
		Если НЕ ЗначениеЗаполнено(СтрокаДерева["Колонка" + Ном])
			И НЕ ЗначениеЗаполнено(СтрокаДерева.Представление) Тогда
			
			Значение = "<Отсутствует>";		
			
			ЗначениеОтсутствует = Истина;
			
		Иначе
			
			Если ЗначениеЗаполнено(СтрокаДерева.Представление) Тогда	
				
				Значение = СтрокаДерева.Представление;
				
			КонецЕсли;    	
			
		КонецЕсли; 	
		
		Если СтрокаДерева.ЭтоГруппа Тогда
			
			ВыводимаяОбласть = ОбластьГруппа;
			
		Иначе 			
			
			ВыводимаяОбласть = ОбластьСтрока;
			
		КонецЕсли;		
				
		ВыводимаяОбласть.Параметры.Значение	= Значение;
		
		
		Если Значение = "<Отсутствует>" Тогда
			
			ВыводимаяОбласть.ТекущаяОбласть.ЦветФона = WebЦвета.Розовый; 
			
		Иначе
			
			ВыводимаяОбласть.ТекущаяОбласть.ЦветФона = WebЦвета.СлоноваяКость;
		
		КонецЕсли;		
		
		ТабличныйДокумент.Присоединить(ВыводимаяОбласть);  
		
	КонецЦикла; 	
	
	Если НЕ ЕстьПодчиненные Тогда
		
		ТабличныйДокумент.Вывести(ОбластьНачалоСтроки, Уровень + 1,, Ложь); 
		
		Для Ном = 1 По Конвертации.Количество() Цикл 		
			
			Значение = СтрокаДерева["Колонка" + Ном];			
					
			Если СтрокаДерева.ЭтоГруппа Тогда
				
				ВыводимаяОбласть = ОбластьГруппа;
				
			Иначе 			
				
				ВыводимаяОбласть = ОбластьСтрока;
				
			КонецЕсли;	
			
			ВыводимаяОбласть.Параметры.Значение			= ПодготовитьЗначениеДляСравнения(Значение);
			ВыводимаяОбласть.ТекущаяОбласть.ЦветФона	= WebЦвета.Белый;  
			
			ТабличныйДокумент.Присоединить(ВыводимаяОбласть);  
			
		КонецЦикла; 	
		
	КонецЕсли;   	
	
	Если ЕстьПодчиненные И НЕ ЗначениеОтсутствует Тогда
		
		УровеньПодчиненный = Уровень + 1;
		
		Для каждого СтрокаПодчиненная ИЗ СтрокаДерева.Строки Цикл
			
			ВывестиСтрокиРекурсивно(УровеньПодчиненный, ТабличныйДокумент, ОбластьНачалоСтроки, ОбластьГруппа,
				ОбластьСтрока, СтрокаПодчиненная); 
			
		КонецЦикла;		
		
	КонецЕсли;	
	
КонецПроцедуры // ВывестиСтрокиРекурсивно()

///////////////////////////////////////////////////////////////////////////////
// ФУНКЦИИ РАБОТЫ С ФЛАЖКАМИ

// Выполняет рекурсивную установку флажков в подчиненных строках переданной строки 
// дерева значений.
//
// Параметры:
//  СтрокаДереваЗначений - Строка дерева значений - строка дерева значений, в
//                         подчиненных строках которой необходимо установить флажок.
//  Значение - Число - значение пометки.
//
Процедура УстановитьФлажки(СтрокаДереваЗначений, Значение)
	
	Для каждого ПодчиненнаяСтрока Из СтрокаДереваЗначений.Строки Цикл
		
		ПодчиненнаяСтрока.Пометка = Значение;
		
		УстановитьФлажки(ПодчиненнаяСтрока, ПодчиненнаяСтрока.Пометка);
		
	КонецЦикла;

КонецПроцедуры // УстановитьФлажки()

// Выполняет проверку подчиненных строк на соответствие текущей пометки - пометке
// переданной строки дерева значений.
// 
// Параметры:
//  СтрокаДереваЗначений - Строка дерева значений - строка дерева значений,
//                         в подчиненных строках которой должна быть выполнена
//                         проверка.
//
Функция УстановленоДляВсех(СтрокаДереваЗначений)
	
	Для каждого Стр Из СтрокаДереваЗначений.Родитель.Строки Цикл
		
		Если Стр.Пометка <> СтрокаДереваЗначений.Пометка Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции // УстановленоДляВсех()

// Выполняет установку пометки в родительских строках текущей строки дерева значений.
//
// Параметры:
//  СтрокаДереваЗначений - Строка дерева значений - строка дерева значений,
//                         в родительской строке которой должно быть изменено
//                         значение пометки.
//
Процедура УстановитьПометкуРодителя(Знач СтрокаДереваЗначений)
	
	Пока СтрокаДереваЗначений.Родитель <> Неопределено Цикл
		
		СтрокаДереваЗначений.Родитель.Пометка = ?(УстановленоДляВсех(СтрокаДереваЗначений), СтрокаДереваЗначений.Пометка, 2);
		
		СтрокаДереваЗначений = СтрокаДереваЗначений.Родитель;
		
	КонецЦикла;
	
КонецПроцедуры // УстановитьПометкуРодителя()

// Выполняет рекурсивную установку флажков в подчиненных строках переданной строки дерева значений.
//
// Параметры:
//  СтрокаДереваЗначений - Строка дерева значений - строка дерева значений, подчиненные строки которой
//                         должны быть обработаны.
//  Пометка - Число - значение пометки.
//
Процедура ИзменитьПометкиПодчиненных(СтрокаДереваЗначений, Пометка)
	
	СтрокаДереваЗначений.Пометка = Пометка;
	
	Для каждого ПодчиненнаяСтрока ИЗ СтрокаДереваЗначений.Строки Цикл
		
		ИзменитьПометкиПодчиненных(ПодчиненнаяСтрока, Пометка);
		
	КонецЦикла;
	
КонецПроцедуры // ИзменитьПометкиПодчиненных()

// Выполняет поиск помеченных строк дерева значений и устанавливает флажки в их подчиненных и родительских строках.
// 
// Параметры:
//  Дерево - Дерево значений - дерево значений, в котором необходимо расставить флажки.
//
Процедура УстановитьФлажкиДерева(Дерево)
	
	ОтмеченныеСтроки = Дерево.Строки.НайтиСтроки(Новый Структура("Пометка", 1), Истина);
	
	Для каждого Строка Из ОтмеченныеСтроки Цикл
		
		УстановитьФлажки(Строка, Строка.Пометка);
		
		УстановитьПометкуРодителя(Строка);
		
	КонецЦикла;
	
КонецПроцедуры // УстановитьФлажкиДерева()

///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДЕРЕВОМ СРАВНЕНИЯ 

// Добавляет в дерево значений - реквизит обработки "ДеревоСравнения" обязательные колонки.
//
Процедура ПодготовитьСтруктуруДереваСравнения() 
	
	ДеревоСравнения.Строки.Очистить();
	ДеревоСравнения.Колонки.Очистить();
	
	ДеревоСравнения.Колонки.Добавить("Пометка"				, Новый ОписаниеТипов("Число"));
	ДеревоСравнения.Колонки.Добавить("ЭтоГруппа"			, Новый ОписаниеТипов("Булево"));
	ДеревоСравнения.Колонки.Добавить("ВозможноОбъединение"	, Новый ОписаниеТипов("Булево"));
	ДеревоСравнения.Колонки.Добавить("Путь"					, Новый ОписаниеТипов("Строка"));
	ДеревоСравнения.Колонки.Добавить("Представление"		, Новый ОписаниеТипов("Строка"));
	ДеревоСравнения.Колонки.Добавить("НомерСтроки"			, Новый ОписаниеТипов("Число"));
	
	ДобавитьКолонкиКонвертаций();
	
КонецПроцедуры // ПодготовитьСтруктуруДереваСравнения()

// Добавляет в дерево значений - реквизит обработки "ДеревоСравнения" колонки, соответствующие строкам
// табличной части "Конвертации".
//
Процедура ДобавитьКолонкиКонвертаций() 
	
	СоответствияПравил = Новый Соответствие;
	
	ТипКолонки = Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(3, 0));
	
	Для каждого СтрокаТабличнойЧасти Из Конвертации Цикл
		
		НомерКолонки = СтрокаТабличнойЧасти.НомерСтроки;
		
		ДеревоСравнения.Колонки.Добавить("Колонка" + НомерКолонки);
		ДеревоСравнения.Колонки.Добавить("ИндексКартинки" + НомерКолонки, ТипКолонки);
		
		Если НомерКолонки < Конвертации.Количество() Тогда
		
			ДеревоСравнения.Колонки.Добавить("Различия" + НомерКолонки, ТипКолонки);
			ДеревоСравнения.Колонки.Добавить("ЕстьРазличия" + НомерКолонки, Новый ОписаниеТипов("Булево"));
			
		КонецЕсли;
		
		СоответствияПравил.Вставить(СтрокаТабличнойЧасти.Конвертация, НомерКолонки);
		
	КонецЦикла;
	
КонецПроцедуры // ДобавитьКолонкиКонвертаций()

// Выполняет вывод дерева значений "ДеревоСравнения" в табличное поле формы
// "ДеревоРезультатСравнения" в соответствии со значением фильтров отбора.
//
Процедура СформироватьДеревоРезультатСравнения() 
	
	УстановитьФлажкиДерева(ДеревоСравнения);
	
	УстановитьРазличияСтрок(ДеревоСравнения);
	
	ИсходноеДеревоСравнения = ДеревоСравнения.Скопировать();
	
	ПрименитьЗначениеФильтраОтбора(ИсходноеДеревоСравнения, ИсходноеДеревоСравнения);
	
	УстановитьФлажкиДерева(ИсходноеДеревоСравнения);
	
	УстановитьРазличияСтрок(ИсходноеДеревоСравнения);

	ДеревоРезультатСравнения = ИсходноеДеревоСравнения;
	
	ЭлементыФормы.ДеревоРезультатСравнения.СоздатьКолонки();
	
	ЭлементыФормы.ДеревоРезультатСравнения.Колонки.НомерСтроки.Видимость			= Ложь;
	ЭлементыФормы.ДеревоРезультатСравнения.Колонки.Пометка.Видимость				= Ложь;
	ЭлементыФормы.ДеревоРезультатСравнения.Колонки.ЭтоГруппа.Видимость				= Ложь;
	ЭлементыФормы.ДеревоРезультатСравнения.Колонки.Путь.Видимость					= Ложь;
	ЭлементыФормы.ДеревоРезультатСравнения.Колонки.Представление.Видимость			= Ложь;
	ЭлементыФормы.ДеревоРезультатСравнения.Колонки.ВозможноОбъединение.Видимость	= Ложь;
	
	Для каждого СтрокаТабличнойЧасти Из Конвертации Цикл
		
		НомерКолонки = СтрокаТабличнойЧасти.НомерСтроки;
		
		ИмяКолонки = "Колонка" + НомерКолонки;
		
		Колонка = ЭлементыФормы.ДеревоРезультатСравнения.Колонки[ИмяКолонки];
		
		Колонка.ТекстШапки						= СтрокаТабличнойЧасти.Конвертация.Наименование;
		Колонка.ОтображатьИерархию				= Истина;
		Колонка.ТриСостоянияФлажка				= Истина;
		Колонка.ГоризонтальноеПоложениеВКолонке	= ГоризонтальноеПоложение.Лево;
		Колонка.ИзменениеРазмера				= ИзменениеРазмераКолонки.Изменять;
		Колонка.КартинкиСтрок					= БиблиотекаКартинок.КоллекцияОбъектыМетаданных;
		
		ЭлементыФормы.ДеревоРезультатСравнения.Колонки["ИндексКартинки" + НомерКолонки].Видимость = Ложь;
		
		ИмяКолонки = "Различия" + НомерКолонки;
		
		Если ЭлементыФормы.ДеревоРезультатСравнения.Колонки.Найти(ИмяКолонки) <> Неопределено Тогда
			
			Колонка = ЭлементыФормы.ДеревоРезультатСравнения.Колонки[ИмяКолонки];
			
			Колонка.ТекстШапки			= "";
			Колонка.ИзменениеРазмера	= ИзменениеРазмераКолонки.НеИзменять;
			Колонка.КартинкиСтрок		= БиблиотекаКартинок.КоллекцияОбъектыМетаданных;
			
		КонецЕсли;
		
		ИмяКолонки = "ЕстьРазличия" + НомерКолонки;
		
		Если ЭлементыФормы.ДеревоРезультатСравнения.Колонки.Найти(ИмяКолонки) <> Неопределено Тогда
			
			ЭлементыФормы.ДеревоРезультатСравнения.Колонки[ИмяКолонки].Видимость = Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
		
	УстановитьВидимость();
	
КонецПроцедуры // СформироватьДеревоРезультатСравнения() 

// Применяет значение текущего фильтра к переданной строке.
//
// Параметры:
//  ДеревоРезультат - Дерево значений - дерево значений в котором находится текущая строка.
//  СтрокаДерева - Строка дерева значений - текущая строка дерева значений.
//
Процедура ПрименитьЗначениеФильтраКТекущейСтрокеДерева(ДеревоРезультат, СтрокаДерева) 
	
	Если ФильтрОтбора = 0 Тогда
		
		Возврат;
		
	КонецЕсли;
	
	РодительскаяСтрока = СтрокаДерева.Родитель;
	
	Если РодительскаяСтрока = Неопределено Тогда
		
		СформироватьДеревоРезультатСравнения();
		
	Иначе
		
		ПрименитьЗначениеФильтраОтбора(ДеревоРезультат, РодительскаяСтрока);
		
		Если РодительскаяСтрока.Строки.Количество() = 0
			И РодительскаяСтрока.Родитель <> Неопределено Тогда
			
			РодительскаяСтрока.Пометка = 0;
			
			СтруктураКолонок = НовыйСтруктураКолонок("ЕстьРазличия", Конвертации.Количество() - 1, Ложь);
				
			ЗаполнитьЗначенияСвойств(РодительскаяСтрока, СтруктураКолонок);
			
			УстановитьФлажкиДерева(РодительскаяСтрока);
			
			УстановитьРазличияСтрок(РодительскаяСтрока);
			
			ПрименитьЗначениеФильтраКТекущейСтрокеДерева(ДеревоРезультат, РодительскаяСтрока);
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры // ПрименитьЗначениеФильтраКТекущейСтрокеДерева()

///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБЪЕДИНЕНИЯ ПРАВИЛ ОБМЕНА 

// Определяет имя типа по переданному значению.
//
// Параметры:
//  ПроверяемыйОбъект - Произвольный - объект, для которого необходимо определить тип.
//
// Возвращаемое значение:
//  Строка - Имя базового типа.
//
Функция ПолучитьИмяБазовогоТипаПоТипуОбъекта(ПроверяемыйОбъект) 
	
	Если ТипЗнч(ПроверяемыйОбъект) = Тип("ОбъектМетаданных") Тогда
		
		МетаданныеТипа = ПроверяемыйОбъект;
		
	Иначе
		
		ТипОбъекта = ТипЗнч(ПроверяемыйОбъект);
		
		Если ПримитивныеТипы.Найти(ТипОбъекта) <> Неопределено Тогда
			
			Возврат "";
			
		КонецЕсли;
				
		МетаданныеТипа = Метаданные.НайтиПоТипу(ТипОбъекта);
		
	КонецЕсли;
	
	Если Метаданные.ПланыОбмена.Содержит(МетаданныеТипа) Тогда
		
		Возврат "ПланОбмена";
		
	ИначеЕсли Метаданные.Справочники.Содержит(МетаданныеТипа) Тогда
		
		Возврат "Справочник";
		
	ИначеЕсли Метаданные.Перечисления.Содержит(МетаданныеТипа) Тогда
		
		Возврат "Перечисление";
		
	ИначеЕсли Метаданные.Документы.Содержит(МетаданныеТипа) Тогда
		
		Возврат "Документ";
		
	ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(МетаданныеТипа) Тогда
		
		Возврат "ПланВидовХарактеристик";
		
	ИначеЕсли Метаданные.ПланыСчетов.Содержит(МетаданныеТипа) Тогда
		
		Возврат "ПланСчетов";
		
	ИначеЕсли Метаданные.ПланыВидовРасчета.Содержит(МетаданныеТипа) Тогда
		
		Возврат "ПланВидовРасчета";
		
	ИначеЕсли Метаданные.РегистрыСведений.Содержит(МетаданныеТипа) Тогда
		
		Возврат "РегистрСведений";
		
	ИначеЕсли Метаданные.РегистрыНакопления.Содержит(МетаданныеТипа) Тогда
		
		Возврат "РегистрНакопления";
		
	ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(МетаданныеТипа) Тогда
		
		Возврат "РегистрБухгалтерии";
		
	ИначеЕсли Метаданные.РегистрыРасчета.Содержит(МетаданныеТипа) Тогда
		
		Возврат "РегистрРасчета";
		
	ИначеЕсли Метаданные.БизнесПроцессы.Содержит(МетаданныеТипа) Тогда
		
		Возврат "БизнесПроцесс";
		
	ИначеЕсли Метаданные.Задачи.Содержит(МетаданныеТипа) Тогда
		
		Возврат "Задача";
		
	Иначе
		
		Возврат "";
		
	КонецЕсли;

КонецФункции // ПолучитьИмяБазовогоТипаПоТипуОбъекта()

// Создает массив реквизитов, которые должны быть скопированы в приемник из источника.
//
// Параметры:
//
//  СправочникИмя - Строка - имя справочника, для которого нужно получить массив реквизитов.
//
Функция НовыйМассивРеквизитов(СправочникИмя)
	
	МассивРеквизитов = Новый Массив;
	
	Если СравниваемыеРеквизиты.Свойство(СправочникИмя) Тогда
		
		ТаблицаРеквизитов = СравниваемыеРеквизиты[СправочникИмя];
		
		СтруктураРеквизитов = Новый Структура;
		
		Для каждого СтрокаТаблицы Из ТаблицаРеквизитов Цикл
			
			Если НеобходимоСравнитьРеквизит(СправочникИмя, СтрокаТаблицы.Путь) Тогда 
				
				МассивРеквизитов.Добавить(СтрокаТаблицы.Путь);
				
			КонецЕсли;
			
		КонецЦикла;
		
	Иначе
		
		СтруктураРеквизитов = НовыйСтруктураРеквизитовОбъектаМетаданных("Справочники", СправочникИмя);
		
		Для каждого КлючИЗначение Из СтруктураРеквизитов Цикл
			
			МассивРеквизитов.Добавить(КлючИЗначение.Ключ); 
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат МассивРеквизитов;
	
КонецФункции // НовыйМассивРеквизитов()

// Получает реквизиты объекта метаданных в виде структуры.
//
// Параметры
//  Класс - Строка - Класс объекта ("Справочники", "Документы", "Задачи" и т.п.).
//  Вид - Строка - Вид объекта метаданных.
//
// Возвращаемое значение:
//  СтруктураРеквизитов - Структура - структура реквизитов в ключах которой находятся
//                        имена реквизитов объекта метаданных.
//
Функция НовыйСтруктураРеквизитовОбъектаМетаданных(Класс, Вид)
	
	Менеджер = Метаданные[Класс][Вид];
	
	СтруктураРеквизитов = Новый Структура;
	
	Для каждого Реквизит Из Менеджер.Реквизиты Цикл
		
		СтруктураРеквизитов.Вставить(Реквизит.Имя);
		
	КонецЦикла;
	
	Возврат СтруктураРеквизитов;
	
КонецФункции // НовыйСтруктураРеквизитовОбъектаМетаданных()

// Создает структуру реквизитов объекта метаданных для заполнения с учетом выбранных пользователем значений реквизитов.
//
// Параметры:
//  ИмяСправочника - Строка - Имя справочника.
//  ЭтоГруппа - Булево - флаг группы.
//  Объект - Произвольный - конвертируемая ссылка.
//  НеобходимыеРеквизиты - Массив - в элементах массива содержатся строки с именами реквизитов справочника.
//
// Возвращаемое значение:
//  СтруктураРеквизитов - Структура, в ключах которой хранятся имена реквизитов объекта метаданных.
//
Функция НовыйСтруктураМетаданныхОбъекта(ИмяСправочника, ЭтоГруппа, Объект, НеобходимыеРеквизиты)
	
	ОбъектМетаданных = Метаданные.Справочники[ИмяСправочника];
	
	СтруктураРеквизитов = Новый Структура;
	СтруктураРеквизитов.Вставить("ПометкаУдаления");
	
	Если НЕ ЭтоГруппа Тогда
		
		Если ИмяСправочника = "Алгоритмы" Тогда
			
			СтруктураРеквизитов.Вставить("Алгоритм");
			
		ИначеЕсли ИмяСправочника = "Запросы" Тогда
			
			СтруктураРеквизитов.Вставить("ТекстЗапроса");
			
		КонецЕсли;	
		
	КонецЕсли;	
	
	Если ОбъектМетаданных.ДлинаКода > 0 Тогда
		
		СтруктураРеквизитов.Вставить("Код");
		
	КонецЕсли;
	
	Если ОбъектМетаданных.ДлинаНаименования > 0 Тогда
		
		СтруктураРеквизитов.Вставить("Наименование");
		
	КонецЕсли;
	
	Если ОбъектМетаданных.Иерархический Тогда
		
		СтруктураРеквизитов.Вставить("Родитель");
		
		Если ОбъектМетаданных.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов Тогда
			
			СтруктураРеквизитов.Вставить("ЭтоГруппа");
			
		КонецЕсли;
		
	КонецЕсли;	
	
	Если ОбъектМетаданных.Владельцы.Количество() > 0 Тогда
		
		СтруктураРеквизитов.Вставить("Владелец");
		
	КонецЕсли;
	
	Для каждого Реквизит Из ОбъектМетаданных.Реквизиты Цикл
		
		Если НеобходимыеРеквизиты.Найти(Реквизит.Имя) = Неопределено Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		Если ЭтоГруппа Тогда
			
			Если Реквизит.Использование <> Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента Тогда
				
				СтруктураРеквизитов.Вставить(Реквизит.Имя);
				
			КонецЕсли;
			
		Иначе
			
			Если Реквизит.Использование <> Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы Тогда
				
				СтруктураРеквизитов.Вставить(Реквизит.Имя);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла; 
	
	Возврат СтруктураРеквизитов;
	
КонецФункции // НовыйСтруктураМетаданныхОбъекта()

// Выполняет очистку значения в колонке - приемнике, если значение в колонке - источнике отсутствует.
//
// Параметры:
//  СтрокаДерева - Строка дерева значений - текущая строка дерева.
//  КолонкаИсточник - Строка - имя колонки - источника.
//  КолонкаПриемник - Строка - имя колонки - приемника.
//  КолонкаРазличия - Строка - имя колонки с признаком различия.
//
Процедура ОчиститьЗначенияПолейВСтрокеДерева(СтрокаДерева, КолонкаИсточник, КолонкаПриемник,
	КолонкаРазличия, КолонкаЕстьРазличия)
	
	СтрокаДерева[КолонкаЕстьРазличия] = ?(СравниватьПомеченныеНаУдаление, Истина, Ложь);
	СтрокаДерева[КолонкаРазличия] = -3;
	СтрокаДерева.Пометка = 0;
	
	ВыполнитьСравнениеСтроки(СтрокаДерева);
	
	СтрокаДереваСравнения = СоответствиеНомеровСтрокДерева[СтрокаДерева.НомерСтроки];
	
	ЗаполнитьЗначенияСвойств(СтрокаДереваСравнения, СтрокаДерева);
	
	Для каждого ПодчиненнаяСтрока Из СтрокаДерева.Строки Цикл
		
		ОчиститьЗначенияПолейВСтрокеДерева(ПодчиненнаяСтрока, КолонкаИсточник, КолонкаПриемник, КолонкаРазличия,
			КолонкаЕстьРазличия);
		
	КонецЦикла;
	
КонецПроцедуры // ОчиститьЗначенияПолейВСтрокеДерева()

// Выполняет поиск, а при отсутствии - создает новый элемент справочника.
//
// Параметры:
//  Вид - Строка, содержит имя объекта метаданных
//  ПоляПоиска - Структура, в ключах которой содержится имя реквизита объекта, а в значениях - значения этих реквизитов.
//               По ключам этой структуры выполняется поиск объекта в информационной базе.
//  Реквизиты - Структура, в ключах которой содержится имя реквизита объекта, а в значениях - значения этих реквизитов.
//              Эта структура используется для заполнения объекта.
//  ТабличныеЧасти - Структура, в ключах которой содержатся имя табличных частей, а в значениях - таблицы значений, имена
//                   колонок которых соответствуют структуре табличных частей документов.
//  ЗамещатьОбъект - Булево. Признак необходимости перезаполнить реквизиты найденного объекта.
//  ВернутьОбъект - Булево. Признак необходимости вернуть объект базы данных до его записи.
//
// Возвращаемое значение:
//  Ссылка на найденный или вновь созданный объект.
//
Функция ПолучитьСоздатьСсылку(Вид, ПоляПоиска, Реквизиты, ТабличныеЧасти = Неопределено,
	ЗамещатьОбъект = Истина, ВернутьОбъект = Ложь)
	
	СтандартныеРеквизиты = Новый Массив;
	СтандартныеРеквизиты.Добавить("Ссылка");
	СтандартныеРеквизиты.Добавить("ЭтоГруппа");
	СтандартныеРеквизиты.Добавить("Код");
	СтандартныеРеквизиты.Добавить("Наименование");
	СтандартныеРеквизиты.Добавить("Родитель");
	СтандартныеРеквизиты.Добавить("Владелец");
	СтандартныеРеквизиты.Добавить("Предопределенный");
	
	Запрос = Новый Запрос;
	
	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	" + Вид + ".Ссылка
	|ИЗ
	|	Справочник." + Вид + " КАК " + Вид;
	
	ТекстУсловия = ""; 
	
	Если ТипЗнч(ПоляПоиска) = Тип("Структура") Тогда
		
		Для каждого КлючИЗначение Из ПоляПоиска Цикл
			
			Поле     = КлючИЗначение.Ключ;
			Значение = КлючИЗначение.Значение;
			
			Если СтандартныеРеквизиты.Найти(Поле) = Неопределено Тогда
				
				Если Справочники[Вид].Реквизиты.Найти(Поле) = Неопределено Тогда
					
					Продолжить;
					
				КонецЕсли;
				
			КонецЕсли;
			
			Если ТипЗнч(Значение) = Тип("Строка") Тогда
				
				СтрокаУсловия = "" + Вид + "." + Поле + " ПОДОБНО &" + Поле;
				
			Иначе
				
				СтрокаУсловия = "" + Вид + "." + Поле + " = &" + Поле;
				
			КонецЕсли;
			
			Если ПустаяСтрока(ТекстУсловия) Тогда
				
				ТекстУсловия = "
				|ГДЕ
				|	" + СтрокаУсловия;
				
			Иначе
				
				ТекстУсловия = ТекстУсловия + "
				|	И " + СтрокаУсловия; 
				
			КонецЕсли;
			
			Если ТипЗнч(Значение) = Тип("Строка") Тогда
				Запрос.УстановитьПараметр(Поле, СокрЛП(Значение) + "%");
			Иначе
				Запрос.УстановитьПараметр(Поле, Значение);
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Запрос.Текст = ТекстЗапроса + ТекстУсловия;
	
	Результат = Запрос.Выполнить();
	
	Выборка = Результат.Выбрать();
	
	Если Выборка.Следующий() Тогда
		
		ОбъектСсылка = Выборка.Ссылка;
		
		Объект = ОбъектСсылка.ПолучитьОбъект();
		
	Иначе
		
		ЭтоГруппа = Ложь;
		
		Если Реквизиты.Свойство("ЭтоГруппа") Тогда
			
			ЭтоГруппа = Реквизиты.ЭтоГруппа;
			
		КонецЕсли;
		
		Если ЭтоГруппа Тогда
			
			Объект = Справочники[Вид].СоздатьГруппу();
			
		Иначе
			
			Объект = Справочники[Вид].СоздатьЭлемент();
			
		КонецЕсли;
		
	КонецЕсли;
	
	ЭтоНовый = Объект.ЭтоНовый();
	
	Если НЕ ЗамещатьОбъект И НЕ ЭтоНовый Тогда
		
		Если ВернутьОбъект Тогда
			
			Возврат Объект;
			
		Иначе
			
			Возврат Объект.Ссылка;
			
		КонецЕсли;
	
	КонецЕсли;
	
	// Выполним проверку на различие реквизитов объекта.
	
	Если НЕ ЭтоНовый Тогда
		
		ВнесеныИзменения = Ложь;
		
		// Проверка реквизитов объекта.
		
		Для каждого КлючИЗначение Из Реквизиты Цикл
			
			Если Объект[КлючИЗначение.Ключ] <> КлючИЗначение.Значение Тогда
				
				ВнесеныИзменения = Истина;
				
				Прервать;
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если НЕ ВнесеныИзменения Тогда
			
			// Реквизиты объекта не были изменены, записывать не  нужно.
			
			Возврат Объект.Ссылка;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если ЭтоНовый Тогда
		
		// Проверим на автонумерацию.
		
		Если НЕ Метаданные.Справочники[Вид].АвтоНумерация Тогда
			
			Попытка
				
				Объект.СгенерироватьУникальныйКод();
				
			Исключение
				
				Объект.УстановитьНовыйКод();
				
			КонецПопытки;
			
		КонецЕсли;
		
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(Объект, Реквизиты);
	
	Если ТабличныеЧасти <> Неопределено Тогда
		
		Для каждого КлючИЗначение Из ТабличныеЧасти Цикл
			
			Если Справочники[Вид].ТабличныеЧасти.Найти(КлючИЗначение.Ключ) <> Неопределено Тогда
				
				ТабличнаяЧасть = Объект[КлючИЗначение.Ключ];
				ТабличнаяЧасть.Загрузить(КлючИЗначение.Значение);
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Если ВернутьОбъект Тогда
		
		Возврат Объект;
		
	КонецЕсли;
	
	// Запишем объект в информационную базу.
	
	Попытка
		
		Если ТипЗнч(Объект) = Тип("СправочникОбъект.ПравилаКонвертацииОбъектов")
			ИЛИ ТипЗнч(Объект) = Тип("СправочникОбъект.ПравилаКонвертацииСвойств")
			ИЛИ ТипЗнч(Объект) = Тип("СправочникОбъект.ПравилаВыгрузкиДанных") Тогда
			
			Объект.мЗагрузкаДанных = Истина;
			
		КонецЕсли;
		
		Объект.Записать();
		
	Исключение
		
		Сообщить(ОписаниеОшибки());
		
	КонецПопытки;
	
	Возврат Объект.Ссылка;
	
КонецФункции // ПолучитьСоздатьСсылкуНаОбъект()

// Конвертирует реквизит-источник в реквизит-приемник.
//
// Параметры:
//  Конвертация - СправочникСсылка.Конвертации - конвертация - приемник.
//  КонвертируемаяСсылка - Произвольный - ссылка на конвертируемое значение.
//  КолонкаИсточник - Строка - имя колонки - источника.
//  КолонкаПриемник - Строка - имя колонки - приемника.
//  КолонкаРазличия - Строка - имя колонки, хранящей признаки различий. 
// 
// Возвращаемое значение:
//  Ссылка на созданный или найденный элемент.
//
Функция КонвертироватьЗначениеРеквизита(Конвертация, КонвертируемаяСсылка, КолонкаИсточник,
		КолонкаПриемник, КолонкаРазличия)
	
	Если НЕ ЗначениеЗаполнено(КонвертируемаяСсылка)
		ИЛИ ПримитивныеТипы.Найти(ТипЗнч(КонвертируемаяСсылка)) <> Неопределено
		ИЛИ ПоддерживаемыеТипы.Найти(ТипЗнч(КонвертируемаяСсылка)) = Неопределено Тогда
		
		Возврат КонвертируемаяСсылка;
		
	КонецЕсли;
	
	МетаданныеОбъекта = КонвертируемаяСсылка.Метаданные(); 
	
	СтруктураРеквизитов = НовыйСтруктураМетаданныхОбъекта(МетаданныеОбъекта.Имя, КонвертируемаяСсылка.ЭтоГруппа,
		КонвертируемаяСсылка, НовыйМассивРеквизитов(МетаданныеОбъекта.Имя));
	
	Для каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		
		ЗначениеСравнения = КонвертируемаяСсылка[КлючИЗначение.Ключ];
		
		Если НЕ ЗначениеЗаполнено(ЗначениеСравнения) Тогда
			Продолжить;
		КонецЕсли;
		
		Если ПоддерживаемыеТипы.Найти(ТипЗнч(КонвертируемаяСсылка)) = Неопределено Тогда
			
			// Примитивные типы данных просто переносим "как есть".
			
			СтруктураРеквизитов[КлючИЗначение.Ключ] = ЗначениеСравнения; 			
			
		Иначе
			
			Если КлючИЗначение.Ключ = "Родитель" Тогда
				
				Если МетаданныеОбъекта.Иерархический И ЗначениеЗаполнено(КонвертируемаяСсылка) Тогда
					
					СтруктураРеквизитов[КлючИЗначение.Ключ] = КонвертироватьЗначениеРеквизита(Конвертация, ЗначениеСравнения,
						КолонкаИсточник, КолонкаПриемник, КолонкаРазличия);
					
				КонецЕсли;
				
			ИначеЕсли КлючИЗначение.Ключ = "Владелец" Тогда
				
				Если ТипЗнч(КонвертируемаяСсылка.Владелец) = Тип("СправочникСсылка.Конвертации") Тогда
					
					СтруктураРеквизитов[КлючИЗначение.Ключ] = Конвертация;
					
				ИначеЕсли ТипЗнч(КонвертируемаяСсылка.Владелец) = Тип("СправочникСсылка.Конфигурации") Тогда
					
					Если КонвертируемаяСсылка.Владелец = Конвертация.Источник Тогда
						
						СтруктураРеквизитов[КлючИЗначение.Ключ] = Конвертация.Источник;
						
					Иначе 
						
						СтруктураРеквизитов[КлючИЗначение.Ключ] = Конвертация.Приемник;
						
					КонецЕсли;
					
				Иначе
					
					СтруктураРеквизитов[КлючИЗначение.Ключ] = КонвертироватьЗначениеРеквизита(Конвертация, КонвертируемаяСсылка.Владелец,
						КолонкаИсточник, КолонкаПриемник, КолонкаРазличия);  
					
				КонецЕсли;
				
			Иначе
				
				СтруктураРеквизитов[КлючИЗначение.Ключ] = КонвертироватьЗначениеРеквизита(Конвертация, ЗначениеСравнения,
					КолонкаИсточник, КолонкаПриемник, КолонкаРазличия); 
				
			КонецЕсли;
			
		КонецЕсли; 
		
	КонецЦикла;
	
	ПоляПоиска = Новый Структура;
	
	Если МетаданныеОбъекта.ДлинаКода > 0 И МетаданныеОбъекта.КонтрольУникальности Тогда
		
		ПоляПоиска.Вставить("Код");
		
	Иначе
		
		ПоляПоиска.Вставить("Наименование");
		
	КонецЕсли;
	
	Если СтруктураРеквизитов.Свойство("Владелец") Тогда
		
		ПоляПоиска.Вставить("Владелец"); 
		
	КонецЕсли;	
	
	Если СтруктураРеквизитов.Свойство("Родитель") И ЗначениеЗаполнено(СтруктураРеквизитов.Родитель) Тогда
		
		ПоляПоиска.Вставить("Родитель");
		
	КонецЕсли;	
	
	Если СтруктураРеквизитов.Свойство("ЭтоГруппа") Тогда
		
		ПоляПоиска.Вставить("ЭтоГруппа");
		
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(ПоляПоиска, СтруктураРеквизитов);
	
	Возврат ПолучитьСоздатьСсылку(МетаданныеОбъекта.Имя, ПоляПоиска, СтруктураРеквизитов);
	
КонецФункции // КонвертироватьЗначениеРеквизита()

// Копирует значение-источник и устанавливает скопированное значение в колонке - приемнике.
//
// Параметры:
//  Конвертация - СправочникСсылка.Конвертации - конвертация - приемник.
//  КолонкаИсточник - Строка - имя колонки - источника.
//  КолонкаПриемник - Строка - имя колонки - приемника.
//  КолонкаРазличия - Строка - имя колонки, хранящей признаки различий.
//
Процедура СкопироватьЗначениеИсточника(Конвертация, СтрокаДерева, КолонкаИсточник, КолонкаПриемник,
	КолонкаРазличия, КолонкаЕстьРазличия)
	
	ЗначениеИсточник = СтрокаДерева[КолонкаИсточник];
	ЗначениеПриемник = КонвертироватьЗначениеРеквизита(Конвертация, ЗначениеИсточник, КолонкаИсточник
		, КолонкаПриемник, КолонкаРазличия);

	СтрокаДерева[КолонкаПриемник]		= ЗначениеПриемник;
	СтрокаДерева.Пометка				= 0;
	СтрокаДерева[КолонкаРазличия]		= 0;
	СтрокаДерева[КолонкаЕстьРазличия]	= Ложь;
	
	// Заполним значение приемника в дереве анализа.
	
	ГруппыУзлов = Новый Массив;
	ГруппыУзлов.Добавить("Реквизиты");
	ГруппыУзлов.Добавить("Алгоритмы");
	
	Для каждого Группа Из ГруппыУзлов Цикл
		
		СтрокаУзла = СтрокаДерева.Строки.Найти(Группа, "Путь");
		
		Если СтрокаУзла <> Неопределено Тогда
			
			СтрокаУзла.Пометка = 0;
			СтрокаУзла[КолонкаРазличия] = 0;
			СтрокаУзла[КолонкаЕстьРазличия] = Ложь;
			
			СтрокиПомеченные = СтрокаУзла.Строки.НайтиСтроки(Новый Структура("Пометка", 1));
			
			Для каждого ПомеченнаяСтрока Из СтрокиПомеченные Цикл
				
				ПомеченнаяСтрока[КолонкаПриемник] = ЗначениеПриемник[ПомеченнаяСтрока.Путь];
				ПомеченнаяСтрока.Пометка = 0;
				ПомеченнаяСтрока[КолонкаРазличия] = 0;
				ПомеченнаяСтрока[КолонкаЕстьРазличия] = Ложь;
				
				ВыполнитьСравнениеСтроки(ПомеченнаяСтрока);
				
				СтрокаДереваСравнения = СоответствиеНомеровСтрокДерева[ПомеченнаяСтрока.НомерСтроки];
				
				ЗаполнитьЗначенияСвойств(СтрокаДереваСравнения, ПомеченнаяСтрока);
				
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ВыполнитьСравнениеСтроки(СтрокаДерева);
	
	СтрокаДереваСравнения = СоответствиеНомеровСтрокДерева[СтрокаДерева.НомерСтроки];
	
	ЗаполнитьЗначенияСвойств(СтрокаДереваСравнения, СтрокаДерева);
	
КонецПроцедуры // СкопироватьЗначениеИсточника()

// Копирует выбранные реквизиты объекта-источника в объект-приемник.
//
// Параметры:
//  Конвертация - СправочникСсылка.Конвертации - конвертация - приемник.
//  СтрокаДерева - Строка дерева значений - текущая строка дерева.
//  КолонкаИсточник - Строка - имя колонки - источника.
//  КолонкаПриемник - Строка - имя колонки - приемника.
//  КолонкаРазличия - Строка - имя колонки, хранящей признаки различий.
//  КолонкаЕстьРазличия - Строка - имя колонки, хранящей флаги различий.
//
Процедура ОбъединитьЗначенияПолей(Конвертация, СтрокаДерева, КолонкаИсточник, КолонкаПриемник,
	КолонкаРазличия, КолонкаЕстьРазличия)
	
	ЗначениеПриемник = СтрокаДерева[КолонкаПриемник];
	ЗначениеИсточник = СтрокаДерева[КолонкаИсточник];
	
	ИмяТипа = ПолучитьИмяБазовогоТипаПоТипуОбъекта(ЗначениеПриемник);
	
	Если ИмяТипа <> "Справочник" Тогда
		
		Возврат;
		
	КонецЕсли;
	
	СправочникОбъект = ЗначениеПриемник.ПолучитьОбъект();
	СправочникМетаданные = СправочникОбъект.Метаданные();
	
	ВнесеныИзменения = Ложь;
	
	Если СтрокаДерева.Путь = "ПКЗ" Тогда
		
		СправочникОбъект.Источник = КонвертироватьЗначениеРеквизита(Конвертация, ЗначениеИсточник.Источник, КолонкаИсточник,
			КолонкаПриемник, КолонкаРазличия);
		СправочникОбъект.Приемник = КонвертироватьЗначениеРеквизита(Конвертация, ЗначениеИсточник.Приемник, КолонкаИсточник,
			КолонкаПриемник, КолонкаРазличия);
		
		ВнесеныИзменения = Истина;
		
	Иначе
		
		Если СтрокаДерева.Строки.Количество() = 0 Тогда
			
			ЗначениеПриемник = КонвертироватьЗначениеРеквизита(Конвертация, ЗначениеИсточник, КолонкаИсточник, КолонкаПриемник,
				КолонкаРазличия);
			
			СправочникОбъект = ЗначениеПриемник.ПолучитьОбъект();
			
			ВнесеныИзменения = Истина;
			
		Иначе
			
			Если СтрокаДерева.Путь = "Алгоритм" ИЛИ СтрокаДерева.Путь = "Запрос" Тогда
				
				Если СтрокаДерева[КолонкаРазличия] <> 0 Тогда
					
					Если СтрокаДерева.Путь = "Алгоритм" Тогда   				
						
						СправочникОбъект.Алгоритм = СтрокаДерева[КолонкаИсточник].Алгоритм;
						
					Иначе
						
						СправочникОбъект.ТекстЗапроса = СтрокаДерева[КолонкаИсточник].ТекстЗапроса; 
						
					КонецЕсли;
					
					ВнесеныИзменения = Истина;
					
				КонецЕсли;
				
			КонецЕсли;
			
			ГруппыУзлов = Новый Массив;
			ГруппыУзлов.Добавить("Реквизиты");
			ГруппыУзлов.Добавить("Алгоритмы");
			
			Для каждого Группа Из ГруппыУзлов Цикл
				
				// Найдем подчиненную строку, содержащую список отмеченных реквизитов.
				
				Если СтрокаДерева.Родитель = Неопределено Тогда
					
					СтрокаОбщие = СтрокаДерева.Строки.Найти("РазделОбщие", "Путь");
					
					Если СтрокаОбщие = Неопределено Тогда
						
						Продолжить;
						
					КонецЕсли;
					
					СтрокаПодчиненная = СтрокаОбщие.Строки.Найти(Группа, "Путь");
					
				Иначе
					
					СтрокаПодчиненная = СтрокаДерева.Строки.Найти(Группа, "Путь");
					
				КонецЕсли;
				
				Если СтрокаПодчиненная = Неопределено Тогда
					
					Продолжить;
					
				КонецЕсли;
				
				СтрокаПодчиненная.Пометка				= 0;
				СтрокаПодчиненная[КолонкаРазличия]		= 0;
				СтрокаПодчиненная[КолонкаЕстьРазличия]	= Ложь;
				
				// Конвертируем отмеченные реквизиты.
				
				СтрокиПомеченные = СтрокаПодчиненная.Строки.НайтиСтроки(Новый Структура("Пометка", 1));
				
				Для каждого ВыбраннаяСтрока Из СтрокиПомеченные Цикл
					
					РеквизитМетаданных = СправочникМетаданные.Реквизиты.Найти(ВыбраннаяСтрока.Путь);
					
					Если ВыбраннаяСтрока[КолонкаРазличия] = 0 ИЛИ РеквизитМетаданных = Неопределено Тогда
						
						Продолжить;
						
					КонецЕсли;
					
					Если СправочникМетаданные.Иерархический
						И СправочникМетаданные.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов Тогда
						
						Если (СправочникОбъект.ЭтоГруппа
							И РеквизитМетаданных.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента)
							ИЛИ (НЕ СправочникОбъект.ЭтоГруппа
							И РеквизитМетаданных.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы) Тогда
							
							Продолжить;
							
						КонецЕсли;
						
					КонецЕсли;
					
					НовыйРеквизит = КонвертироватьЗначениеРеквизита(Конвертация, ВыбраннаяСтрока[КолонкаИсточник], КолонкаИсточник,
						КолонкаПриемник, КолонкаРазличия);  
						
					СправочникОбъект[ВыбраннаяСтрока.Путь] = НовыйРеквизит;
					
					ВыбраннаяСтрока[КолонкаПриемник] = НовыйРеквизит;
					ВыбраннаяСтрока[КолонкаЕстьРазличия] = Ложь;
					ВыбраннаяСтрока[КолонкаРазличия] = 0;
					
					ВыполнитьСравнениеСтроки(ВыбраннаяСтрока);
					
					СтрокаДереваСравнения = СоответствиеНомеровСтрокДерева[ВыбраннаяСтрока.НомерСтроки];
					
					ЗаполнитьЗначенияСвойств(СтрокаДереваСравнения, ВыбраннаяСтрока);
					
					ВнесеныИзменения = Истина;
					
				КонецЦикла;
				
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если ВнесеныИзменения Тогда
		
		СтрокаДерева.Пометка				= 0;
		СтрокаДерева[КолонкаРазличия]		= 0;
		СтрокаДерева[КолонкаЕстьРазличия]	= Ложь;
		
		СправочникОбъект.ПометкаУдаления = Ложь;
		
		СправочникОбъект.Записать();
		
		// Выполним сравнение в других строках дерева сравнения. 
		
		ДеревоЗначений = СтрокаДерева.Владелец();
		
		СтруктураОтбор = Новый Структура(КолонкаПриемник, ЗначениеПриемник);
		
		СтрокиПодчиненные = ДеревоЗначений.Строки.НайтиСтроки(СтруктураОтбор, Истина);
		
		Для каждого ПодчиненнаяСтрока Из СтрокиПодчиненные Цикл
			
			ПодчиненнаяСтрока.Пометка				= 0;
			ПодчиненнаяСтрока[КолонкаРазличия]		= 0;
			ПодчиненнаяСтрока[КолонкаЕстьРазличия]	= Ложь;     
			
			ВыполнитьСравнениеСтроки(ПодчиненнаяСтрока);
			
			// Перенесем изменения в дерево сравнения.
			
			СтрокаДереваСравнения = СоответствиеНомеровСтрокДерева[ПодчиненнаяСтрока.НомерСтроки];
			
			ЗаполнитьЗначенияСвойств(СтрокаДереваСравнения, ПодчиненнаяСтрока);
			
			Если ПодчиненнаяСтрока.Строки.Количество() > 0 Тогда
				
				ПерезаполнитьСтрокиПравила(СправочникОбъект, ПодчиненнаяСтрока, КолонкаПриемник, КолонкаРазличия, КолонкаЕстьРазличия);
				
			КонецЕсли;	
			
			УстановитьФлажкиДерева(ПодчиненнаяСтрока);
			
		КонецЦикла;
		
		ВыполнитьСравнениеСтроки(СтрокаДерева);
		
		// Перенесем изменения в дерево сравнения.
		
		СтрокаДереваСравнения = СоответствиеНомеровСтрокДерева[СтрокаДерева.НомерСтроки];
		
		ЗаполнитьЗначенияСвойств(СтрокаДереваСравнения, СтрокаДерева);
		
		УстановитьФлажкиДерева(СтрокаДерева);
		
	КонецЕсли;
	
КонецПроцедуры // ОбъединитьЗначенияПолей()

// Выполняет заполнение подчиненных строк реквизитов и обработчиков перезаписанного объекта.
//
// Параметры:
//  СправочникОбъект - СправочникОбъект - перезаписанный объект, для которого необходимо выполнить
//                     обновление подчиненных строк дерева.
//  СтрокаДерева - Строка таблицы значений - строка дерева значений, в которой необходимо выполнить
//                 обновление значений.
//  КолонкаПриемник - Строка - имя колонки - приемника.
//  КолонкаРазличия - Строка - имя колонки, хранящей признаки различий.
//  КолонкаЕстьРазличия - Строка - имя колонки, хранящей флаги различий.
//
Процедура ПерезаполнитьСтрокиПравила(СправочникОбъект, СтрокаДерева, КолонкаПриемник,
	КолонкаРазличия, КолонкаЕстьРазличия) 
	
	Для каждого ПодчиненнаяСтрока Из СтрокаДерева.Строки Цикл 
		
		Если ПодчиненнаяСтрока.ЭтоГруппа   			
			И (ПодчиненнаяСтрока.Путь <> "Алгоритмы" И ПодчиненнаяСтрока.Путь <> "Реквизиты") Тогда
			
			Продолжить;
			
		КонецЕсли;  
		
		ПодчиненнаяСтрока.Пометка				= 0;
		ПодчиненнаяСтрока[КолонкаРазличия]		= 0;
		ПодчиненнаяСтрока[КолонкаЕстьРазличия]	= Ложь;  	     
		
		Если ПодчиненнаяСтрока.ЭтоГруппа Тогда 			
			
			ПерезаполнитьСтрокиПравила(СправочникОбъект, ПодчиненнаяСтрока, КолонкаПриемник,
				КолонкаРазличия, КолонкаЕстьРазличия); 
			
		Иначе  
			
			ПодчиненнаяСтрока[КолонкаПриемник] = СправочникОбъект[ПодчиненнаяСтрока.Путь];
			
			ВыполнитьСравнениеСтроки(ПодчиненнаяСтрока);
			
			// Перенесем изменения в дерево сравнения.
			
			СтрокаДереваСравнения = СоответствиеНомеровСтрокДерева[ПодчиненнаяСтрока.НомерСтроки];
			
			ЗаполнитьЗначенияСвойств(СтрокаДереваСравнения, ПодчиненнаяСтрока);   
			
		КонецЕсли; 		
		
		УстановитьФлажкиДерева(ПодчиненнаяСтрока);	
		
	КонецЦикла; 	
	
КонецПроцедуры // ПерезаполнитьСтрокиПравила() 

// Выполняет объединение данных в строке дерева значений.
//
// Параметры:
//  СтрокаДерева - Строка дерева значений - текущая строка дерева.
//  КолонкаИсточник - Строка - имя колонки - источника.
//  КолонкаПриемник - Строка - имя колонки - приемника.
//  КолонкаРазличия - Строка - имя колонки, хранящей признаки различий.
//
Процедура ОбъединитьДанныеСтроки(СтрокаДерева, КолонкаИсточник, КолонкаПриемник, КолонкаРазличия, КолонкаЕстьРазличия)
	
	КонвертацияИсточник = Конвертации[ОставитьТолькоЦифры(КолонкаИсточник, Истина) -1].Конвертация;
	КонвертацияПриемник = Конвертации[ОставитьТолькоЦифры(КолонкаПриемник, Истина) -1].Конвертация;
	
	ЗначениеИсточник = СтрокаДерева[КолонкаИсточник];
	ЗначениеПриемник = СтрокаДерева[КолонкаПриемник];
	
	Если НЕ ЗначениеЗаполнено(ЗначениеПриемник) 
		И НЕ ЗначениеЗаполнено(ЗначениеИсточник) Тогда
		
		// Объединять не нужно.
		
	ИначеЕсли ЗначениеЗаполнено(ЗначениеПриемник) И НЕ ЗначениеЗаполнено(ЗначениеИсточник)
		И (ТипЗнч(ЗначениеПриемник) = Тип("СправочникСсылка.Конвертации")
		ИЛИ ТипЗнч(ЗначениеПриемник) = Тип("СправочникСсылка.Параметры")
		ИЛИ ТипЗнч(ЗначениеПриемник) = Тип("СправочникСсылка.ПравилаКонвертацииОбъектов")
		ИЛИ ТипЗнч(ЗначениеПриемник) = Тип("СправочникСсылка.ПравилаКонвертацииСвойств")
		ИЛИ ТипЗнч(ЗначениеПриемник) = Тип("СправочникСсылка.ПравилаКонвертацииЗначений")
		ИЛИ ТипЗнч(ЗначениеПриемник) = Тип("СправочникСсылка.ПравилаВыгрузкиДанных")
		ИЛИ ТипЗнч(ЗначениеПриемник) = Тип("СправочникСсылка.ПравилаОчисткиДанных")
		ИЛИ ТипЗнч(ЗначениеПриемник) = Тип("СправочникСсылка.Алгоритмы")
		ИЛИ ТипЗнч(ЗначениеПриемник) = Тип("СправочникСсылка.Запросы")) Тогда
		
		// Устанавливаем пометку удаления на приемнике.
		
		СправочникОбъект = ЗначениеПриемник.ПолучитьОбъект();
		
		Попытка
			
			СправочникОбъект.УстановитьПометкуУдаления(Истина, Истина);
			
			ОчиститьЗначенияПолейВСтрокеДерева(СтрокаДерева, КолонкаИсточник, КолонкаПриемник, КолонкаРазличия,
				КолонкаЕстьРазличия);
			
		Исключение
		КонецПопытки;
		
	ИначеЕсли (НЕ ЗначениеЗаполнено(ЗначениеПриемник) И ЗначениеЗаполнено(ЗначениеИсточник))
		ИЛИ ТипЗнч(ЗначениеПриемник) <> ТипЗнч(ЗначениеИсточник) Тогда
		
		СкопироватьЗначениеИсточника(КонвертацияПриемник, СтрокаДерева, КолонкаИсточник, КолонкаПриемник, КолонкаРазличия,
			КолонкаЕстьРазличия);
		
	Иначе
		
		ОбъединитьЗначенияПолей(КонвертацияПриемник, СтрокаДерева, КолонкаИсточник, КолонкаПриемник, КолонкаРазличия,
			КолонкаЕстьРазличия);
		
	КонецЕсли;
	
КонецПроцедуры // ОбъединитьДанныеСтроки()

// Выполняет рекурсивный поиск строк дерева значений, значения в колонках которых должны быть объединены.
//
// Параметры:
//  МассивСтрок - Массив - содержит список строк дерева значений.
//  СтрокаДерева - Строка дерева значений - текущая строка дерева.
//  КолонкаИсточник - Строка - имя колонки - источника.
//  КолонкаПриемник - Строка - имя колонки - приемника.
//
Процедура НайтиСтрокиДляОбъединения(МассивСтрок, СтрокаДерева, КолонкаИсточник, КолонкаПриемник, КолонкаЕстьРазличия)
	
	ЗначениеИсточник = СтрокаДерева[КолонкаИсточник];
	ЗначениеПриемник = СтрокаДерева[КолонкаПриемник];
	
	Если СтрокаДерева.Пометка > 0 Тогда
		
		Если СтрокаДерева[КолонкаЕстьРазличия]
			И (ПоддерживаемыеТипы.Найти(ТипЗнч(ЗначениеИсточник)) <> Неопределено 
			ИЛИ ПоддерживаемыеТипы.Найти(ТипЗнч(ЗначениеПриемник)) <> Неопределено) Тогда
			
			Если ЗначениеЗаполнено(ЗначениеПриемник) 
				ИЛИ ЗначениеЗаполнено(ЗначениеИсточник) Тогда
				
				МассивСтрок.Добавить(СтрокаДерева);
				
			КонецЕсли;
			
		КонецЕсли;
		
		Для каждого ПодчиненнаяСтрока Из СтрокаДерева.Строки Цикл
			
			НайтиСтрокиДляОбъединения(МассивСтрок, ПодчиненнаяСтрока, КолонкаИсточник, КолонкаПриемник, КолонкаЕстьРазличия);
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры // НайтиСтрокиДляОбъединения()

// Выполняет инициализацию процесса объединения текущей и подчиненных строк.
//
// Параметры:
//  СтрокаДерева - Строка дерева значений - текущая строка дерева.
//  КолонкаИсточник - Строка - имя колонки - источника.
//  КолонкаПриемник - Строка - имя колонки - приемника.
//  КолонкаРазличия - Строка - имя колонки, хранящей признаки различий.
//  КолонкаЕстьРазличия - Булево - имя колонки, хранящей флаг различий.
//
Процедура ВыполнитьОбъединениеПравил(СтрокаДерева, КолонкаИсточник,
	КолонкаПриемник, КолонкаРазличия, КолонкаЕстьРазличия) 
	
	ПодчиненныеСтроки = Новый Массив;
	
	НайтиСтрокиДляОбъединения(ПодчиненныеСтроки, СтрокаДерева, КолонкаИсточник, КолонкаПриемник, КолонкаЕстьРазличия);	
	
	ФормаИндикации = ПолучитьОбщуюФорму("ХодВыполненияОбработкиДанных", ЭтаФорма);
	
	КолонкаИсточникТекст = """" + СокрЛП(СтрокаДерева[КолонкаИсточник]) + """";
	КолонкаПриемникТекст = """" + СокрЛП(СтрокаДерева[КолонкаПриемник]) + """";
	
	ТекстКомментария = НСтр("ru = 'Объединяется: %КолонкаИсточник% с %КолонкаПриемник%'");
	ТекстКомментария = СтрЗаменить(ТекстКомментария, "%КолонкаИсточник%", КолонкаИсточникТекст);
	ТекстКомментария = СтрЗаменить(ТекстКомментария, "%КолонкаПриемник%", КолонкаПриемникТекст);
	
	ФормаИндикации.МаксимальноеЗначение			= ПодчиненныеСтроки.Количество();
	ФормаИндикации.НаименованиеОбработкиДанных	= НСтр("ru = 'Объединение правил обмена'");
	ФормаИндикации.КомментарийОбработкиДанных	= ТекстКомментария;
	
	ФормаИндикации.Открыть();
	
	Ном = 0;
	
	Для каждого СтрокаПодчиненная Из ПодчиненныеСтроки Цикл
		
		ЗначениеИсточник = СтрокаПодчиненная[КолонкаИсточник];
		ЗначениеПриемник = СтрокаПодчиненная[КолонкаПриемник];
		
		Ном = Ном + 1;
		
		ИсточникТекст = ?(НЕ ЗначениеЗаполнено(ЗначениеПриемник), "<Отсутствует>", СокрЛП(ЗначениеПриемник));
		ПриемникТекст =  ?(НЕ ЗначениеЗаполнено(ЗначениеИсточник), "<Отсутствует>", СокрЛП(ЗначениеИсточник));
		
		ТекстКомментария = НСтр("ru = 'Объединяется: %Приемник% с %Источник%'");
		ТекстКомментария = СтрЗаменить(ТекстКомментария, "%Источник%", ИсточникТекст);
		ТекстКомментария = СтрЗаменить(ТекстКомментария, "%Приемник%", ПриемникТекст);
		
		ФормаИндикации.Значение = Ном;
		ФормаИндикации.КомментарийЗначения = ТекстКомментария;
		
		ОбъединитьДанныеСтроки(СтрокаПодчиненная, КолонкаИсточник, КолонкаПриемник, КолонкаРазличия, КолонкаЕстьРазличия);
		
	КонецЦикла;	
	
	ФормаИндикации.Закрыть();
	
КонецПроцедуры // ВыполнитьОбъединениеПравил()

// Объединяет строки правил с помощью KDiff3.
//
// Параметры:
//  СтрокаДерева - Строка дерева значений - текущая строка дерева.
//  КолонкаИсточник - Строка - имя колонки - источника.
//  КолонкаПриемник - Строка - имя колонки - приемника.
//
Процедура ВыполнитьОбъединениеПравилKDiff3(СтрокаДерева, КолонкаИсточник, КолонкаПриемник) 
	
	ЗначениеПриемник = СтрокаДерева[КолонкаПриемник];
	ЗначениеИсточник = СтрокаДерева[КолонкаИсточник];	
	
	Если ТипЗнч(ЗначениеИсточник) = Тип("СправочникСсылка.Алгоритмы") Тогда
		
		ЗначениеИсточник = ЗначениеИсточник.Алгоритм;
		
	ИначеЕсли ТипЗнч(ЗначениеИсточник) = Тип("СправочникСсылка.Запросы") Тогда
		
		ЗначениеИсточник = ЗначениеИсточник.ТекстЗапроса;
		
	КонецЕсли;	
	
	Если ТипЗнч(ЗначениеПриемник) = Тип("СправочникСсылка.Алгоритмы") Тогда
		
		ЗначениеПриемник = ЗначениеПриемник.Алгоритм;
		
	ИначеЕсли ТипЗнч(ЗначениеПриемник) = Тип("СправочникСсылка.Запросы") Тогда
		
		ЗначениеПриемник = ЗначениеПриемник.ТекстЗапроса;
		
	КонецЕсли;	
	
	ЗначениеИсточник = ПодготовитьДляСравнения(ЗначениеИсточник);
	ЗначениеПриемник = ПодготовитьДляСравнения(ЗначениеПриемник);
	
	РезультатОбъединения = ОбъединитьСПомощьюKDiff3(ЗначениеПриемник, ЗначениеИсточник);
	
	ЗначениеПриемник = СтрокаДерева[КолонкаПриемник];
	
	Если ТипЗнч(ЗначениеПриемник) = Тип("СправочникСсылка.Алгоритмы") Тогда
		
		СправочникОбъект = ЗначениеПриемник.ПолучитьОбъект();
		СправочникОбъект.Алгоритм = РезультатОбъединения;
		СправочникОбъект.Записать();
		
	ИначеЕсли ТипЗнч(ЗначениеПриемник) = Тип("СправочникСсылка.Запросы") Тогда
		
		СправочникОбъект = ЗначениеПриемник.ПолучитьОбъект();
		СправочникОбъект.ТекстЗапроса = РезультатОбъединения;
		СправочникОбъект.Записать();
		
	Иначе 		
		
		СправочникОбъект = Неопределено;
		
		СтрокаПоиска = СтрокаДерева;
		
		Пока СправочникОбъект = Неопределено 
			ИЛИ СтрокаПоиска.Родитель = Неопределено Цикл 
			
			Если ПоддерживаемыеТипы.Найти(ТипЗнч(СтрокаПоиска[КолонкаПриемник])) <> Неопределено Тогда
				
				СправочникОбъект = СтрокаПоиска[КолонкаПриемник].ПолучитьОбъект();
				
				Прервать;
				
			КонецЕсли;	
			
			СтрокаПоиска = СтрокаПоиска.Родитель;
			
		КонецЦикла; 	
		
		СтрокаДерева[КолонкаПриемник] = РезультатОбъединения;
		
		СправочникОбъект[СтрокаДерева.Путь] = РезультатОбъединения;
		
		СправочникОбъект.Записать();
		
	КонецЕсли;
	
КонецПроцедуры // ВыполнитьОбъединениеПравилKDiff3() 
 
///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ СРАВНЕНИЯ ПРАВИЛ ОБМЕНА

// Выполняет подготовку данных для анализа и передает их процедурам сравнения.
//
// Параметры:
//  Вариант - Строка - вариант сравнения.
//  ЛеваяКолонка - Число - положение левой колонки относительно текущей.
//  ПраваяКолонка - Число - положение правой колонки относительно текущей.
//
Процедура ВыполнитьАнализРазличийФайлов(Вариант = "СравнениеФайлов", ЛеваяКолонка, ПраваяКолонка)
	
	ТекущиеДанные = ЭлементыФормы.ДеревоРезультатСравнения.ТекущиеДанные;
	
	Если ТекущиеДанные = Неопределено Тогда
		
		Возврат;
		
	КонецЕсли;
	
	ТекущаяКолонка = ЭлементыФормы.ДеревоРезультатСравнения.ТекущаяКолонка;
	
	Если Найти(ТекущаяКолонка.Имя, "Колонка") = 0 Тогда
		
		Возврат;
		
	КонецЕсли;
	
	НомерКолонки = ОставитьТолькоЦифры(ТекущаяКолонка.Имя, Истина);
	
	ЛевоеЗначение  = ТекущиеДанные["Колонка" + (НомерКолонки + ЛеваяКолонка)];
	ПравоеЗначение = ТекущиеДанные["Колонка" + (НомерКолонки + ПраваяКолонка)];
	
	Если Вариант = "СравнениеФайлов" Тогда
		
		ПоказатьРазличияФайлов(ЛевоеЗначение, ПравоеЗначение);
		
	ИначеЕсли Вариант = "СравнениеМодулейВыгрузки" Тогда
		
		ПоказатьРазличияМодулейВыгрузки(ЛевоеЗначение, ПравоеЗначение);
		
	ИначеЕсли Вариант = "СравнениеМодулейЗагрузки" Тогда
		
		ПоказатьРазличияМодулейЗагрузки(ЛевоеЗначение, ПравоеЗначение);
		
	КонецЕсли;
	
КонецПроцедуры // ВыполнитьАнализРазличийФайлов()

// Выполняет сохранение значений во временные файлы и вызывает диалог сравнения файлов.
//
// Параметры:
//  ЛевоеЗначение - Произвольный - левое сравниваемое значение.
//  ПравоеЗначение - Произвольный - правое сравниваемое значение.
//
Процедура ПоказатьРазличияФайлов(ЛевоеЗначение, ПравоеЗначение)  	

	Путь = КаталогВременныхФайлов();
	
	ЛевыйФайл  = Новый ТекстовыйДокумент;
	ПравыйФайл = Новый ТекстовыйДокумент;   
	
	ЛевыйФайл.УстановитьТекст("" + ПодготовитьДляСравнения(ЛевоеЗначение));
	ПравыйФайл.УстановитьТекст("" + ПодготовитьДляСравнения(ПравоеЗначение)); 	
	
	ЛевыйФайл.Записать(Путь + "Левое.txt");
	ПравыйФайл.Записать(Путь + "Правое.txt");
	
	СравнениеФайлов = Новый СравнениеФайлов;
	
	СравнениеФайлов.ПервыйФайл						= Путь + "Левое.txt";
	СравнениеФайлов.ВторойФайл						= Путь + "Правое.txt";
	СравнениеФайлов.СпособСравнения					= СпособСравненияФайлов.ТекстовыйДокумент;
	СравнениеФайлов.УчитыватьРегистр				= Истина;
	СравнениеФайлов.ИгнорироватьПустоеПространство	= Истина;
	СравнениеФайлов.ПоказатьРазличия();
	
КонецПроцедуры // ПоказатьРазличияФайлов()

// Выполняет сохранение модулей выгрузки правил обмена, разработанных на платформе 1С:Предприятие 7.7
// во временные файлы и вызывает диалог сравнения файлов.
//
// Параметры:
//  ЛевоеЗначение - СправочникСсылка.Конвертации - левая сравниваемая конвертация.
//  ПравоеЗначение - СправочникСсылка.Конвертации - правая сравниваемая конвертация.
//
Процедура ПоказатьРазличияМодулейВыгрузки(ЛевоеЗначение, ПравоеЗначение)
	
	Состояние(НСтр("ru = 'Модули выгрузки сохраняются....'"));
	
	Путь = КаталогВременныхФайлов();
	
	ЛевыйФайл  = Путь + "Левый.txt";
	ПравыйФайл = Путь + "Правый.txt"; 

	// Модуль выгрузки исходных правил.
	
	ОбработкаСохранения = Обработки.ВыгрузкаКонвертации.Создать();
	
	ОбработкаСохранения.КонвертацияДляВыгрузки = ЛевоеЗначение;
	ОбработкаСохранения.ИмяФайлаМодуляВыгрузки = ЛевыйФайл;
	
	ОбработкаСохранения.ВыполнитьВыгрузкуМодуляОбработкиВыгрузки();
	
	// Модуль выгрузки правил сравнения.
	
	ОбработкаСохранения = Обработки.ВыгрузкаКонвертации.Создать();
	
	ОбработкаСохранения.КонвертацияДляВыгрузки = ПравоеЗначение;
	ОбработкаСохранения.ИмяФайлаМодуляВыгрузки = ПравыйФайл;
	
	ОбработкаСохранения.ВыполнитьВыгрузкуМодуляОбработкиВыгрузки();
	
	
	СравнениеФайлов = Новый СравнениеФайлов;
	
	СравнениеФайлов.ПервыйФайл						= ЛевыйФайл;
	СравнениеФайлов.ВторойФайл						= ПравыйФайл;
	СравнениеФайлов.СпособСравнения					= СпособСравненияФайлов.ТекстовыйДокумент;
	СравнениеФайлов.УчитыватьРегистр				= Истина;
	СравнениеФайлов.ИгнорироватьПустоеПространство	= Истина;

	СравнениеФайлов.ПоказатьРазличия();
	
КонецПроцедуры // ПоказатьРазличияМодулейВыгрузки()

// Выполняет сохранение модулей загрузки правил обмена, разработанных на платформе 1С:Предприятие 7.7
// во временные файлы и вызывает диалог сравнения файлов.
//
// Параметры:
//  ЛевоеЗначение - СправочникСсылка.Конвертации - левая сравниваемая конвертация.
//  ПравоеЗначение - СправочникСсылка.Конвертации - правая сравниваемая конвертация.
//
Процедура ПоказатьРазличияМодулейЗагрузки(ЛевоеЗначение, ПравоеЗначение)
	
	Состояние(НСтр("ru = 'Модули загрузки сохраняются....'"));
	
	Путь = КаталогВременныхФайлов();
	
	ЛевыйФайл = Путь + "Левый.txt";
	ПравыйФайл = Путь + "Правый.txt";
	
	// Модуль выгрузки исходных правил.
	
	ОбработкаСохранения = Обработки.ВыгрузкаКонвертации.Создать();
	
	ОбработкаСохранения.КонвертацияДляВыгрузки = ЛевоеЗначение;
	ОбработкаСохранения.ИмяФайлаМодуляЗагрузки = ЛевыйФайл;
	
	ОбработкаСохранения.ВыполнитьВыгрузкуМодуляОбработкиЗагрузки();
	
	// Модуль выгрузки правил сравнения.
	
	ОбработкаСохранения = Обработки.ВыгрузкаКонвертации.Создать();
	
	ОбработкаСохранения.КонвертацияДляВыгрузки = ПравоеЗначение;
	ОбработкаСохранения.ИмяФайлаМодуляЗагрузки = ПравыйФайл;
	
	ОбработкаСохранения.ВыполнитьВыгрузкуМодуляОбработкиЗагрузки();
	
	СравнениеФайлов = Новый СравнениеФайлов;
	
	СравнениеФайлов.ПервыйФайл						= ЛевыйФайл;
	СравнениеФайлов.ВторойФайл						= ПравыйФайл;
	СравнениеФайлов.СпособСравнения					= СпособСравненияФайлов.ТекстовыйДокумент;
	СравнениеФайлов.УчитыватьРегистр				= Истина;
	СравнениеФайлов.ИгнорироватьПустоеПространство	= Истина;

	СравнениеФайлов.ПоказатьРазличия();
	
КонецПроцедуры // ПоказатьРазличияМодулейЗагрузки()
 
// Выполняет приведение значения к строковому типу.
//
// Параметры:
//  Реквизит - Произвольный - значение, которое необходимо привести к строке.
//  ТолькоСравнение - Булево - признак необходимости очистить строку от несущественных символов.
//
// Возвращаемое значение:
//  Результат - реквизит, приведенный к строковому типу.
//
Функция ПодготовитьЗначениеДляСравнения(Знач Реквизит, ТолькоСравнение = Ложь)
	
	Если ТипЗнч(Реквизит) = Тип("СправочникСсылка.Алгоритмы") Тогда
		
		Результат = ПодготовитьДляСравнения(Реквизит.Алгоритм, ТолькоСравнение);
		
	ИначеЕсли ТипЗнч(Реквизит) = Тип("СправочникСсылка.Запросы") Тогда          		
		
		Результат = ПодготовитьДляСравнения(Реквизит.ТекстЗапроса, ТолькоСравнение);
		
	ИначеЕсли НЕ ЗначениеЗаполнено(Реквизит) Тогда
		
		Результат = "";
		
	Иначе
		
		ИмяБазового = ПолучитьИмяБазовогоТипаПоТипуОбъекта(Реквизит);
		
		Если ИмяБазового = "Справочник" Тогда
			
			Если СравниватьСсылкиПоПредставлению Тогда
				
				Результат = ПодготовитьДляСравнения(СокрЛП(Реквизит), ТолькоСравнение);
				
			Иначе				
				
				МетаданныеРеквизита = Реквизит.Метаданные();
				
				МассивРеквизитов = НовыйМассивРеквизитов(МетаданныеРеквизита.Имя);
				
				СтруктураРеквизитов = Новый Структура;
				
				Для каждого РеквизитИмя Из МассивРеквизитов Цикл
					
					СтруктураРеквизитов.Вставить(РеквизитИмя, Реквизит[РеквизитИмя]);
					
				КонецЦикла;
				
				Результат = "";
				
				Для каждого КлючИЗначение Из СтруктураРеквизитов Цикл
					
					Результат = Результат + ?(ПустаяСтрока(Результат), "", Символы.ПС) 
						+ КлючИЗначение.Ключ + ": " + Строка(КлючИЗначение.Значение);
					
				КонецЦикла;  				
				
			КонецЕсли;	
			
		Иначе
			
			Результат = Строка(Реквизит);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ПодготовитьЗначениеДляСравнения()   

// Выполняет установку индексов картинки в зависимости от типа значения, содержащегося в строке.
//
// Параметры
//  СтрокаПравила - Строка дерева значений, в которой необходимо установить индексы картинок.
//  ИндексКартинкиПоУмолчанию - Число - индекс картинки по умолчанию.
//
Процедура УстановитьИндексКартинки(СтрокаПравила, ИндексКартинкиПоУмолчанию = -1)
	
	СоответствияИндексов = Новый Соответствие;
	СоответствияИндексов.Вставить(Неопределено										, -1);
	СоответствияИндексов.Вставить(Перечисления.ТипыОбъектов.Справочник				, 35);
	СоответствияИндексов.Вставить(Перечисления.ТипыОбъектов.Документ				, 36);
	СоответствияИндексов.Вставить(Перечисления.ТипыОбъектов.Перечисление			, 37);
	СоответствияИндексов.Вставить(Перечисления.ТипыОбъектов.ПланСчетов				, 38);
	СоответствияИндексов.Вставить(Перечисления.ТипыОбъектов.ПланВидовРасчета		, 39);
	СоответствияИндексов.Вставить(Перечисления.ТипыОбъектов.ПланВидовХарактеристик	, 40);
	СоответствияИндексов.Вставить(Перечисления.ТипыОбъектов.РегистрБухгалтерии		, 41);
	СоответствияИндексов.Вставить(Перечисления.ТипыОбъектов.РегистрНакопления		, 42);
	СоответствияИндексов.Вставить(Перечисления.ТипыОбъектов.РегистрСведений			, 43);
	СоответствияИндексов.Вставить(Перечисления.ТипыОбъектов.РегистрРасчета			, 44);
	СоответствияИндексов.Вставить(Перечисления.ТипыОбъектов.ПланОбмена				, 45);
	СоответствияИндексов.Вставить(Перечисления.ТипыОбъектов.НаборКонстант			, 46);
	
	ИндексКартинки = -1;
	
	Для каждого СтрокаТабличнойЧасти Из Конвертации Цикл
		
		Если ИндексКартинки >= 0 Тогда
			
			Прервать;
			
		КонецЕсли;
		
		ИмяКолонки = "Колонка" + СтрокаТабличнойЧасти.НомерСтроки;
		
		ПроверяемоеЗначение = СтрокаПравила[ИмяКолонки];
		
		Если ЗначениеЗаполнено(ПроверяемоеЗначение) Тогда
			
			Если ПроверяемоеЗначение.Метаданные().Реквизиты.Найти("Источник") <> Неопределено
				И ПроверяемоеЗначение.Метаданные().Реквизиты.Найти("Приемник") <> Неопределено Тогда
				
				Если ОпределятьТипКартинкиПоИсточнику Тогда
					
					АнализируемыйОбъект = ?(ЗначениеЗаполнено(ПроверяемоеЗначение.Источник), ПроверяемоеЗначение.Источник,
						ПроверяемоеЗначение.Приемник);
					
				Иначе
					
					АнализируемыйОбъект = ?(ЗначениеЗаполнено(ПроверяемоеЗначение.Приемник), ПроверяемоеЗначение.Приемник,
						ПроверяемоеЗначение.Источник);
					
				КонецЕсли;
				
			ИначеЕсли ПроверяемоеЗначение.Метаданные().Реквизиты.Найти("ОбъектВыборки") <> Неопределено Тогда
				
				АнализируемыйОбъект = ПроверяемоеЗначение.ОбъектВыборки;
				
			КонецЕсли;
			
			Если ЗначениеЗаполнено(АнализируемыйОбъект) Тогда
				
				Если АнализируемыйОбъект.Метаданные().Реквизиты.Найти("Тип") <> Неопределено Тогда
					
					ИндексКартинки = СоответствияИндексов[АнализируемыйОбъект.Тип];
					
				ИначеЕсли СтрокаПравила.Путь = "ПКЗ" Тогда
					
					ВладелецОбъекта = АнализируемыйОбъект.Владелец;
					
					Если ВладелецОбъекта.Метаданные().Реквизиты.Найти("Тип") <> Неопределено Тогда
						
						ТипОбъекта = ВладелецОбъекта.Тип;
						
						Если ТипОбъекта = Перечисления.ТипыОбъектов.Справочник
							ИЛИ ТипОбъекта = Перечисления.ТипыОбъектов.ПланВидовХарактеристик Тогда
							
							ИндексКартинки = 30;
							
						ИначеЕсли ТипОбъекта = Перечисления.ТипыОбъектов.ПланСчетов Тогда
							
							ИндексКартинки = 31;
							
						ИначеЕсли ТипОбъекта = Перечисления.ТипыОбъектов.Перечисление Тогда
							
							ИндексКартинки = 32;
							
						ИначеЕсли ТипОбъекта = Перечисления.ТипыОбъектов.ПланВидовРасчета Тогда
							
							ИндексКартинки = 33;
							
						КонецЕсли;
						
					КонецЕсли;
						
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
			
	КонецЦикла;
	
	Если ИндексКартинки < 0 И ИндексКартинкиПоУмолчанию < 0 Тогда
		
		Если СтрокаПравила.ЭтоГруппа Тогда
			
			ИндексКартинки = 1;
			
		Иначе
			
			ИндексКартинки = 3;
			
		КонецЕсли;
		
	ИначеЕсли ИндексКартинки < 0 И ИндексКартинкиПоУмолчанию >= 0 Тогда
		
		ИндексКартинки = ИндексКартинкиПоУмолчанию;
		
	КонецЕсли;
	
	Для каждого СтрокаТабличнойЧасти Из Конвертации Цикл
		
		ИмяКолонки = "ИндексКартинки" + СтрокаТабличнойЧасти.НомерСтроки;
		
		СтрокаПравила[ИмяКолонки] = ИндексКартинки;		
		
	КонецЦикла;
	
КонецПроцедуры // УстановитьИндексКартинки()

// Выполняет предварительную подготовку реквизита для анализа - убирает переносы строк, табуляции, и т.п.
//
// Параметры:
//  Реквизит - Произвольный - анализируемый реквизит.
//  ТолькоСравнение - Булево - признак необходимости очистить строку от несущественных символов.
//
// Возвращаемое значение:
//  Результат - Строка - значение, подготовленное для сравнения. 
//
Функция ПодготовитьДляСравнения(Знач Реквизит, ТолькоСравнение = Ложь) 
	
	Если ТипЗнч(Реквизит) = Тип("Строка") И ТолькоСравнение Тогда
		
		Результат = СтрЗаменить(Реквизит, Символы.ПС, "");
		Результат = СтрЗаменить(Результат, Символы.ВК, "");
		Результат = СтрЗаменить(Результат, Символы.ВТаб, "");
		Результат = СтрЗаменить(Результат, Символы.НПП, "");
		Результат = СтрЗаменить(Результат, Символы.ПС, "");
		Результат = СтрЗаменить(Результат, Символы.ПФ, "");
		Результат = СтрЗаменить(Результат, Символы.Таб, "");
		Результат = СтрЗаменить(Результат, " ", "");
		Результат = СтрЗаменить(Результат, "¶", "");
		
		Возврат НРег(Результат);
		
	ИначеЕсли ТипЗнч(Реквизит) = Тип("Строка")
		ИЛИ ТипЗнч(Реквизит) = Тип("Число")
		ИЛИ ТипЗнч(Реквизит) = Тип("Дата")
		ИЛИ ТипЗнч(Реквизит) = Тип("Булево")
		ИЛИ ТипЗнч(Реквизит) = Тип("Неопределено")
		ИЛИ ТипЗнч(Реквизит) = Тип("NULL") Тогда
			
		Возврат Реквизит;
		
	Иначе
		
		Возврат ПодготовитьЗначениеДляСравнения(Реквизит, ТолькоСравнение);
		
	КонецЕсли;
	
КонецФункции  // ПодготовитьДляСравнения()

// Выполняет сравнение двух значений. При сравнении для значений с типом Строка используется
// СравнениеФайлов, для прочих - Сравнение.
//
// Параметры:
//  ПервоеЗначение - Произвольный - первое сравниваемое значение.
//  ВтороеЗначение - Произвольный - второе сравниваемое значение.
//
// Возвращаемое значение:
//  ЕстьОтличия - Булево - признак того, что значения различаются.
//
Функция НайтиРазличия(ПервоеЗначение, ВтороеЗначение)
	
	Сравнение = Новый СравнениеЗначений;
	
	РезультатСравнения = Сравнение.Сравнить(ПервоеЗначение, ВтороеЗначение);
	
	ЕстьОтличия = РезультатСравнения <> 0;
	
	Возврат ЕстьОтличия;
	
КонецФункции // НайтиРазличия()

// Выполняет поиск различий в переданной строке дерева значений.
//
// Параметры:
//  СтрокаДерева - Строка дерева значений - строка, в колонках которой осуществляется поиск.
//
Процедура ВыполнитьСравнениеСтроки(СтрокаДерева)
	
	Если СтрокаДерева.Родитель = Неопределено
		ИЛИ СтрокаДерева.ЭтоГруппа Тогда
		
		Возврат;
		
	КонецЕсли;
	
	ВыполнитьПроверкуЗаполненияКолонокСтроки(СтрокаДерева);
	
	ЕстьОтличия = Ложь;
	
	Для каждого СтрокаТабличнойЧасти Из Конвертации Цикл
		
		Колонка1 = СтрокаТабличнойЧасти.НомерСтроки;
		Колонка2 = Колонка1 + 1;
		
		Если Колонка2 > Конвертации.Количество() Тогда
			
			Прервать;
			
		КонецЕсли;
		
		ЛевоеЗначение  = СтрокаДерева["Колонка" + Колонка1];
		ПравоеЗначение = СтрокаДерева["Колонка" + Колонка2];
		
		РодительПуть			= СтрокаДерева.Родитель.Путь;
		РодительРазличия		= СтрокаДерева.Родитель["Различия" + Колонка1];
		РодительПометка			= СтрокаДерева.Родитель.Пометка;
		СтрокаДереваРазличия	= СтрокаДерева["Различия" + Колонка1];
		
		Если РодительРазличия = -3
			ИЛИ СтрокаДереваРазличия = -3 Тогда // Значение слева помечено на удаление, а значение справа отсутствует.
			
			СтрокаДерева["Различия" + Колонка1] = -3;
			СтрокаДерева["ЕстьРазличия" + Колонка1] = ?(СравниватьПомеченныеНаУдаление, Истина, Ложь);
			
		ИначеЕсли РодительРазличия = -2
			ИЛИ СтрокаДереваРазличия = -2 Тогда // Отсутствуют оба значения.
			
			СтрокаДерева["Различия" + Колонка1] = -2;
			
		ИначеЕсли (РодительРазличия = -1 ИЛИ СтрокаДереваРазличия = -1) 
			
			ИЛИ (ПримитивныеТипы.Найти(ТипЗнч(ЛевоеЗначение)) = Неопределено
			И ПримитивныеТипы.Найти(ТипЗнч(ПравоеЗначение)) = Неопределено
			И ЗначениеЗаполнено(ЛевоеЗначение)
			И НЕ ЗначениеЗаполнено(ПравоеЗначение)) Тогда // Отсутствует значение справа.
			
			ФлагРазличий = -1;
			ФлагЕстьРазличия = Истина;
			
			Если ПоддерживаемыеТипы.Найти(ТипЗнч(ЛевоеЗначение)) <> Неопределено
				И ЛевоеЗначение.ПометкаУдаления Тогда
				
				ФлагРазличий = -3;
				ФлагЕстьРазличия = ?(СравниватьПомеченныеНаУдаление, Истина, Ложь);
				
			Иначе
				
				ЕстьОтличия = Истина;
				
			КонецЕсли;
			
			СтрокаДерева["Различия" + Колонка1] = ФлагРазличий; 
			СтрокаДерева["ЕстьРазличия" + Колонка1] = ФлагЕстьРазличия;
			
		ИначеЕсли (РодительРазличия = 1 ИЛИ СтрокаДереваРазличия = 1)
			
			ИЛИ (ПримитивныеТипы.Найти(ТипЗнч(ЛевоеЗначение)) = Неопределено
			И ПримитивныеТипы.Найти(ТипЗнч(ПравоеЗначение)) = Неопределено
			И НЕ ЗначениеЗаполнено(ЛевоеЗначение)
			И ЗначениеЗаполнено(ПравоеЗначение)) Тогда // Отсутствует значение слева.
			
			СтрокаДерева["Различия" + Колонка1] = 1;
			СтрокаДерева["ЕстьРазличия" + Колонка1] = Истина;
			
			ЕстьОтличия = Истина;
			
		Иначе
			
			Если ТипЗнч(ЛевоеЗначение) = Тип("СправочникСсылка.ПравилаКонвертацииЗначений") 
				И ТипЗнч(ПравоеЗначение) = Тип("СправочникСсылка.ПравилаКонвертацииЗначений") Тогда
				
				ПервоеЗначениеИсточник = ПодготовитьДляСравнения(ЛевоеЗначение.Источник, Истина);
				ПервоеЗначениеПриемник = ПодготовитьДляСравнения(ЛевоеЗначение.Приемник, Истина);
				
				ВтороеЗначениеИсточник = ПодготовитьДляСравнения(ПравоеЗначение.Источник, Истина);
				ВтороеЗначениеПриемник = ПодготовитьДляСравнения(ПравоеЗначение.Приемник, Истина);
				
				РазличаютсяИсточники = НайтиРазличия(ПервоеЗначениеИсточник, ВтороеЗначениеИсточник);
				РазличаютсяПриемники = НайтиРазличия(ПервоеЗначениеПриемник, ВтороеЗначениеПриемник);
				
				Если РазличаютсяИсточники ИЛИ РазличаютсяИсточники Тогда
					
					ЕстьОтличия = Истина;
					
					СтрокаДерева["Различия" + Колонка1] = 2;
					СтрокаДерева["ЕстьРазличия" + Колонка1] = Истина; 					
					
				КонецЕсли;				
				
			Иначе
				
				ПервоеЗначение = ПодготовитьДляСравнения(ЛевоеЗначение, Истина);
				ВтороеЗначение = ПодготовитьДляСравнения(ПравоеЗначение, Истина);
				
				Если НЕ ЗначениеЗаполнено(ПервоеЗначение) 
					И НЕ ЗначениеЗаполнено(ВтороеЗначение) 
					И ПримитивныеТипы.Найти(ТипЗнч(ПервоеЗначение)) <> Неопределено
					И ПримитивныеТипы.Найти(ТипЗнч(ВтороеЗначение)) <> Неопределено Тогда 
					
					// Отсутствуют значения примитивного типа как слева, так и справа.
					
					СтрокаДерева["Различия" + Колонка1] = 0;
					СтрокаДерева["ЕстьРазличия" + Колонка1] = Ложь; 
					
				Иначе
					
					ФайлыРазличаются = НайтиРазличия(ПервоеЗначение, ВтороеЗначение); 
					
					Если ФайлыРазличаются Тогда						
						
						ЕстьОтличия = Истина;
						
						СтрокаДерева["Различия" + Колонка1] = 2;
						СтрокаДерева["ЕстьРазличия" + Колонка1] = Истина;
						
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЕсли;			
				
		КонецЕсли;
		
	КонецЦикла;
	
	СтрокаДерева.Пометка = ?(ЕстьОтличия, 1, 0);
	
КонецПроцедуры // ВыполнитьСравнениеСтроки()

// Выполняет проверку заполнения колонок строки дерева значений.
//
// Параметры:
//  СтрокаПравила - Строка дерева значений - в которой должны быть выполнены проверки
//                  заполнения колонок.
//
Процедура ВыполнитьПроверкуЗаполненияКолонокСтроки(СтрокаПравила)
	
	// В случае выявления незаполненных значений устанавливает следующие флаги:
	//
	//  -3. Значение слева помечено на удаление, а значение справа отсутствует.
	//  -2. Отсутствует оба значения.
	//  -1. Отсутствует значение справа.
	//   0. Значения идентичны.
	//   1. Отсутствует значение слева.
	//   2. Значения различаются.
	
	Для каждого СтрокаТабличнойЧасти Из Конвертации Цикл
		
		Колонка1 = СтрокаТабличнойЧасти.НомерСтроки;
		Колонка2 = Колонка1 + 1;
		
		Если Колонка2 > Конвертации.Количество() Тогда
			
			Прервать;
			
		КонецЕсли;
		
		ЛевоеЗначение  = СтрокаПравила["Колонка" + Колонка1];
		ПравоеЗначение = СтрокаПравила["Колонка" + Колонка2];
		
		Если ПоддерживаемыеТипы.Найти(ТипЗнч(ЛевоеЗначение)) = Неопределено 
			И ПоддерживаемыеТипы.Найти(ТипЗнч(ПравоеЗначение)) = Неопределено Тогда
			
			СтрокаПравила["Различия" + Колонка1] = 0;
			Продолжить;
			
		КонецЕсли;
		
		Если ЛевоеЗначение = Неопределено И ПравоеЗначение <> Неопределено Тогда
			
			СтрокаПравила["Различия" + Колонка1] = 1;
			
		ИначеЕсли ЛевоеЗначение <> Неопределено И ПравоеЗначение = Неопределено Тогда
			
			Если ПоддерживаемыеТипы.Найти(ТипЗнч(ЛевоеЗначение)) <> Неопределено
				И ЛевоеЗначение.ПометкаУдаления Тогда
				
				СтрокаПравила["Различия" + Колонка1] = -3;
				
			Иначе
				
				СтрокаПравила["Различия" + Колонка1] = -1;  
				
			КонецЕсли;
			
		ИначеЕсли ЛевоеЗначение = Неопределено И ПравоеЗначение = Неопределено Тогда
			
			СтрокаПравила["Различия" + Колонка1] = -2;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // ВыполнитьПроверкуЗаполненияКолонокСтроки()

// Формирует иерархическую структуру правил в дереве сравнения.
//
// Параметры:
//  ИмяСправочника - Строка - имя справочника, по которому должна быть построена иерархия.
//  СтрокаДерева - Строка дерева значений.
//
Процедура СформироватьИерархиюПравил(ИмяСправочника, СтрокаДерева)
	
	МетаданныеСправочника = Метаданные.Справочники[ИмяСправочника];
	
	Если НЕ МетаданныеСправочника.Иерархический Тогда
		
		Возврат;
		
	КонецЕсли;
	
	Запрос = Новый Запрос;
	
	Запрос.УстановитьПараметр("Конвертации", Конвертации.ВыгрузитьКолонку("Конвертация"));
	
	УсловиеНаРодителя = "";
	
	Пока Истина Цикл 	
		
		УсловиеНаРодителя = УсловиеНаРодителя + ".Родитель"; 
		
		ТекстЗапроса = 
		"ВЫБРАТЬ
		|	Правила.Код КАК Имя,
		|	Правила.Родитель.Код КАК Родитель,
		|	Правила.Ссылка КАК Ссылка,
		|	Правила.Владелец КАК Владелец
		|ИЗ
		|	Справочник." + ИмяСправочника + " КАК Правила
		|ГДЕ
		|	Правила.Владелец В (&Конвертации)
		|	И Правила.ЭтоГруппа
		|	И Правила" + УсловиеНаРодителя + " = ЗНАЧЕНИЕ(Справочник." + ИмяСправочника + ".ПустаяСсылка)
		|
		|УПОРЯДОЧИТЬ ПО
		|	Родитель,
		|	Имя
		|ИТОГИ ПО
		|	Родитель,
		|	Имя";
		
		Запрос.Текст = ТекстЗапроса;
		
		Результат = Запрос.Выполнить();
		
		Если Результат.Пустой() Тогда
			
			Прервать;
			
		КонецЕсли;
		
		ВыборкаРодитель = Результат.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
		
		Пока ВыборкаРодитель.Следующий() Цикл
			
			ВыборкаПоКоду = ВыборкаРодитель.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
			
			Пока ВыборкаПоКоду.Следующий() Цикл
				
				УзелРодителя = Неопределено;
				
				Если ЗначениеЗаполнено(ВыборкаПоКоду.Родитель) Тогда
					
					УзелРодителя = СтрокаДерева.Строки.Найти(ВыборкаПоКоду.Родитель, "Представление", Истина);
					
				КонецЕсли;
				
				Если УзелРодителя = Неопределено Тогда
					СтрокаДереваЗначений = СтрокаДерева.Строки.Добавить();
				Иначе
					СтрокаДереваЗначений = УзелРодителя.Строки.Добавить();
				КонецЕсли;
				
				ПрисвоитьУникальныйНомерСтрокеДерева(СтрокаДереваЗначений);
				
				СтрокаДереваЗначений.Представление	= ВыборкаПоКоду.Имя;
				СтрокаДереваЗначений.ЭтоГруппа		= Истина;
				
				ВыборкаДетальныеЗаписи = ВыборкаПоКоду.Выбрать();
				
				Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
					
					ИмяКолонки = "ИндексКартинки" + СоответствияПравил[ВыборкаДетальныеЗаписи.Владелец];
					
					СтрокаДереваЗначений[ИмяКолонки] = 1;
					
					ИмяКолонки = "Колонка" + СоответствияПравил[ВыборкаДетальныеЗаписи.Владелец];
					
					Для каждого СтрокаТабличнойЧасти Из Конвертации Цикл
						
						СтрокаДереваЗначений[ИмяКолонки] = ВыборкаДетальныеЗаписи.Ссылка; 
						
					КонецЦикла;
					
				КонецЦикла;
				
				ВыполнитьПроверкуЗаполненияКолонокСтроки(СтрокаДереваЗначений); 
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры // СформироватьИерархиюПравил()

// Выполняет запрос по справочникам конфигурации.
//
// Параметры:
//  ИмяСправочника - Строка - имя справочника, по которому должен быть построен и выполнен запрос.
// 
// Возвращаемое значение:
//  Результат выполнения запроса.
// 
Функция СформироватьЗапросПоПравилам(ИмяСправочника)
	
	МетаданныеСправочника = Метаданные.Справочники[ИмяСправочника];
	
	Запрос = Новый Запрос;
	
	Запрос.УстановитьПараметр("Конвертации", Конвертации.ВыгрузитьКолонку("Конвертация"));
	
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	Правила.Ссылка КАК Ссылка,
	|	" + ?(МетаданныеСправочника.Иерархический, "Правила.Родитель.Код", """""") + " КАК ИмяРодителя,
	|	Правила.Владелец КАК Конвертация,
	|	Правила.Код КАК Имя,
	|	" + ?(МетаданныеСправочника.Реквизиты.Найти("Порядок") = Неопределено, "0", "Правила.Порядок") + " КАК Порядок
	|ИЗ
	|	Справочник." + ИмяСправочника + " КАК Правила
	|ГДЕ
	|	Правила.Владелец В(&Конвертации)";
	
	Если МетаданныеСправочника.Иерархический 
		И МетаданныеСправочника.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов Тогда
		
		ТекстЗапроса = ТекстЗапроса + "
		|	И (НЕ Правила.ЭтоГруппа)";
		
	КонецЕсли;
	
	ТекстЗапроса = ТекстЗапроса + "
	|
	|УПОРЯДОЧИТЬ ПО
	|	ИмяРодителя,
	|	Порядок,
	|	Имя
	|
	|ИТОГИ ПО
	|	ИмяРодителя,
	|	Имя";
	
	Запрос.Текст = ТекстЗапроса;
	
	Возврат Запрос.Выполнить();
	
КонецФункции // СформироватьЗапросПоПравилам()

// Выполняет запрос по справочнику "Правила конвертации свойств".
// 
// Возвращаемое значение:
//  Результат выполнения запроса.
//  
Функция СформироватьЗапросПоПКС()
	
	Если НЕ СравниватьПравилаКонвертацииСвойств Тогда
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	Запрос = Новый Запрос;
	
	Запрос.УстановитьПараметр("Конвертации", Конвертации.ВыгрузитьКолонку("Конвертация"));
	
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ПравилаКонвертацииСвойств.Владелец.Код КАК ИмяВладельца,
	|	ПравилаКонвертацииСвойств.Родитель.Наименование КАК ИмяРодителя,
	|	ПравилаКонвертацииСвойств." + ?(СравниватьПравилаКонвертацииСвойствПоКоду, "Код", "Наименование") + " КАК Имя,
	|	ПравилаКонвертацииСвойств.Порядок КАК Порядок,
	|	ПравилаКонвертацииСвойств.Ссылка,
	|	ПравилаКонвертацииСвойств.Владелец,
	|	ПравилаКонвертацииСвойств.Родитель,
	|	ПравилаКонвертацииСвойств.Владелец.Владелец КАК Конвертация
	|ИЗ
	|	Справочник.ПравилаКонвертацииСвойств КАК ПравилаКонвертацииСвойств
	|ГДЕ
	|	ПравилаКонвертацииСвойств.Владелец.Владелец В(&Конвертации)
	|	И (НЕ ПравилаКонвертацииСвойств.ЭтоГруппа)
	|
	|УПОРЯДОЧИТЬ ПО
	|	ИмяВладельца,
	|	ИмяРодителя,
	|	Порядок,
	|	Имя
	|ИТОГИ ПО
	|	ИмяВладельца,
	|	ИмяРодителя,
	|	Имя";
	
	Возврат Запрос.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);

КонецФункции // СформироватьЗапросПоПКС()

// Выполняет запрос по справочнику "Правила конвертации значений".
// 
// Возвращаемое значение:
//  Результат выполнения запроса.
//  
Функция СформироватьЗапросПоПКЗ()
	
	Если НЕ СравниватьПравилаКонвертацииЗначений Тогда
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	Запрос = Новый Запрос;
	
	Запрос.УстановитьПараметр("Конвертации", Конвертации.ВыгрузитьКолонку("Конвертация"));
	
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ПравилаКонвертацииЗначений.Владелец.Код КАК ИмяВладельца,
	|	ПравилаКонвертацииЗначений.Родитель.Наименование КАК ИмяРодителя,
	|	ПравилаКонвертацииЗначений.Наименование КАК Имя,
	|	ПравилаКонвертацииЗначений.Порядок КАК Порядок,
	|	ПравилаКонвертацииЗначений.Ссылка,
	|	ПравилаКонвертацииЗначений.Владелец,
	|	ПравилаКонвертацииЗначений.Родитель,
	|	ПравилаКонвертацииЗначений.Владелец.Владелец КАК Конвертация
	|ИЗ
	|	Справочник.ПравилаКонвертацииЗначений КАК ПравилаКонвертацииЗначений
	|ГДЕ
	|	ПравилаКонвертацииЗначений.Владелец.Владелец В(&Конвертации)
	|
	|УПОРЯДОЧИТЬ ПО
	|	ИмяВладельца,
	|	ИмяРодителя,
	|	Порядок,
	|	Имя
	|ИТОГИ ПО
	|	ИмяВладельца,
	|	ИмяРодителя,
	|	Имя";
	
	Возврат Запрос.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	
КонецФункции // СформироватьЗапросПоПКЗ()

// Выполняет заполнение строки реквизитов правил необходимыми значениями.
//
// Параметры:
//  СтрокаПравила - Строка дерева значения - обрабатываемая строка дерева значений.
//  ТаблицаРеквизитов - Таблица дерева значений - содержит перечень реквизитов, 
//                      которые необходимо сравнить.
//  УзлыРеквизитов - Стуктура - содержит строки дерева значений.
//
Процедура ЗаполнитьУзлыРеквизитов(СтрокаПравила, ТаблицаРеквизитов, УзлыРеквизитов)
	
	Для каждого СтрокаТаблицы Из ТаблицаРеквизитов Цикл
		
		Если СтрокаТаблицы.ЭтоАлгоритм Тогда
			
			НоваяСтрока = УзлыРеквизитов.УзелОбработчики.Строки.Добавить();
			НоваяСтрока.Путь = "Алгоритм";
			НоваяСтрока.ВозможноОбъединение = Истина;
			
		Иначе
			
			НоваяСтрока = УзлыРеквизитов.УзелРеквизиты.Строки.Добавить();
			
		КонецЕсли;
		
		ПрисвоитьУникальныйНомерСтрокеДерева(НоваяСтрока);
		
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаТаблицы);
		
		Для каждого СтрокаТабличнойЧасти Из Конвертации Цикл
			
			НомерКолонки = СтрокаТабличнойЧасти.НомерСтроки;
			
			НоваяСтрока["ИндексКартинки" + НомерКолонки] = ?(СтрокаТаблицы.ЭтоАлгоритм, 22, 26);
			
			КолонкаИмя = "Колонка" + НомерКолонки;
			
			ПравилоОбъект = СтрокаПравила[КолонкаИмя];
			
			Если ЗначениеЗаполнено(ПравилоОбъект) Тогда
				
				НоваяСтрока[КолонкаИмя] = ПравилоОбъект[СтрокаТаблицы.Путь];
				
			КонецЕсли;
			
		КонецЦикла;
		
		ВыполнитьСравнениеСтроки(НоваяСтрока);
		
	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьУзлыРеквизитов()

// Выполняет заполнение дерева сравнения узлами правил.
//
// Параметры:
//  ИмяСправочника - Строка - имя справочника, по которому должны быть сформированы узлы.
//  СтрокаДерева - Строка дерева значений - корневой узел вновь формируемых узлов.
//  ВыборкаПКС - Выборка из результата запроса - по справочнику "Правила конвертации свойств".
//  ВыборкаПКЗ - Выборка из результата запроса - по справочнику "Правила конвертации значений".
//
Процедура СформироватьУзлыПравил(ИмяСправочника, СтрокаДерева, ВыборкаПКС = Неопределено, ВыборкаПКЗ = Неопределено)
	
	СформироватьИерархиюПравил(ИмяСправочника, СтрокаДерева);
	
	Результат  = СформироватьЗапросПоПравилам(ИмяСправочника);
	
	СтруктураПутей = Новый Структура;
	СтруктураПутей.Вставить("ПравилаКонвертацииОбъектов", "ПКО");
	СтруктураПутей.Вставить("ПравилаКонвертацииСвойств"	, "ПКС");
	СтруктураПутей.Вставить("ПравилаКонвертацииЗначений", "ПКЗ");
	СтруктураПутей.Вставить("ПравилаВыгрузкиДанных"		, "ПВД");
	СтруктураПутей.Вставить("ПравилаОчисткиДанных"		, "ПОД");
	СтруктураПутей.Вставить("Запросы"					, "Запрос");
	СтруктураПутей.Вставить("Алгоритмы"					, "Алгоритм");
	СтруктураПутей.Вставить("Параметры"					, "Параметр");
	
	СтруктураИндексов = Новый Структура;
	СтруктураИндексов.Вставить("ПравилаКонвертацииОбъектов"	, 19);
	СтруктураИндексов.Вставить("ПравилаКонвертацииСвойств"	, 27);
	СтруктураИндексов.Вставить("ПравилаКонвертацииЗначений"	, -1);
	СтруктураИндексов.Вставить("ПравилаВыгрузкиДанных"		, 20);
	СтруктураИндексов.Вставить("ПравилаОчисткиДанных"		, 21);
	СтруктураИндексов.Вставить("Алгоритмы"					, 22);
	СтруктураИндексов.Вставить("Запросы"					, 23);
	СтруктураИндексов.Вставить("Параметры"					, 48);
	
	ФормаИндикации = ПолучитьОбщуюФорму("ХодВыполненияОбработкиДанных", ЭтаФорма);
	
	ФормаИндикации.НаименованиеОбработкиДанных	= НСтр("ru = 'Выполняется сравнение'");
	ФормаИндикации.КомментарийОбработкиДанных	= Метаданные.Справочники[ИмяСправочника].Синоним;
	ФормаИндикации.МаксимальноеЗначение			= Результат.Выбрать().Количество();
	ФормаИндикации.Открыть();
	
	Ном = 0;
	
	ВыборкаПоРодителю = Результат.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	Пока ВыборкаПоРодителю.Следующий() Цикл
		
		ОбработкаПрерыванияПользователя();
		
		Ном = Ном + 1;
		
		ФормаИндикации.Значение = Ном;
		
		ТекстКомментария = НСтр("ru = 'Обрабатывается: %Родитель%'");
		ТекстКомментария = СтрЗаменить(ТекстКомментария, "%Родитель%", ВыборкаПоРодителю.ИмяРодителя);
		
		ФормаИндикации.КомментарийЗначения = ТекстКомментария;
		
		// Определим узел родителя.
		
		УзелРодителя = Неопределено;
		
		Если ЗначениеЗаполнено(ВыборкаПоРодителю.ИмяРодителя) Тогда
			
			УзелРодителя = СтрокаДерева.Строки.Найти(ВыборкаПоРодителю.ИмяРодителя, "Представление", Истина);
			
		КонецЕсли;
		
		Если УзелРодителя = Неопределено Тогда
			
			УзелРодителя = СтрокаДерева;
			
		КонецЕсли;
		
		// Сформируем подчиненные узлы.
		
		ВыборкаПоКоду = ВыборкаПоРодителю.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
		
		Пока ВыборкаПоКоду.Следующий() Цикл
			
			ОбработкаПрерыванияПользователя();
			
			Ном = Ном + 1;
			
			ФормаИндикации.Значение = Ном;
			
			ТекстКомментария = НСтр("ru = 'Обрабатывается: %Правило%'");
			ТекстКомментария = СтрЗаменить(ТекстКомментария, "%Правило%", ВыборкаПоКоду.Имя);
			
			ФормаИндикации.КомментарийЗначения = ТекстКомментария;
			
			СтрокаПравила = УзелРодителя.Строки.Добавить();
			
			ПрисвоитьУникальныйНомерСтрокеДерева(СтрокаПравила);
			
			ВыборкаДетальная = ВыборкаПоКоду.Выбрать();
			Пока ВыборкаДетальная.Следующий() Цикл
				
				Ном = Ном + 1;
				
				ФормаИндикации.Значение = Ном;
				
				СтрокаПравила["Колонка" + СоответствияПравил[ВыборкаДетальная.Конвертация]] = ВыборкаДетальная.Ссылка;
				
			КонецЦикла;
			
			УстановитьИндексКартинки(СтрокаПравила, СтруктураИндексов[ИмяСправочника]);
			
			СтрокаПравила.Путь = СтруктураПутей[ИмяСправочника];
			
			ВыполнитьПроверкуЗаполненияКолонокСтроки(СтрокаПравила);
			
			Если ИмяСправочника = "Алгоритмы" 
				ИЛИ ИмяСправочника = "Запросы" Тогда
				
				СтрокаПравила.ВозможноОбъединение = Истина;
				
				ВыполнитьСравнениеСтроки(СтрокаПравила);
				
				УзлыРеквизитов = НовыеУзлыРеквизитовДереваСравнения(СтрокаПравила, Ложь); 
				
			Иначе
				
				УзлыРеквизитов = НовыеУзлыРеквизитовДереваСравнения(СтрокаПравила); 
				
			КонецЕсли; 			
			
			ЗаполнитьУзлыРеквизитов(СтрокаПравила, СравниваемыеРеквизиты[ИмяСправочника], УзлыРеквизитов);   
			
			// Заполним ПКС
			
			Если ВыборкаПКС <> Неопределено Тогда
				
				СформироватьУзлыПКС(СтрокаПравила, ВыборкаПоКоду, ВыборкаПКС);
				
			КонецЕсли;
			
			Если ВыборкаПКЗ <> Неопределено Тогда
				
				СформироватьУзлыПКЗ(СтрокаПравила, ВыборкаПоКоду, ВыборкаПКЗ);
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	ФормаИндикации.Закрыть();
	
КонецПроцедуры // СформироватьУзлыПравил()

// Присваивает уникальный номер строки строке дерева значений.
//
// Параметры:
//  СтрокаДереваЗначений - Строка дерева значений, которой необходимо присвоить
//                         уникальный номер.
//
Процедура ПрисвоитьУникальныйНомерСтрокеДерева(СтрокаДереваЗначений)
	
	НомерСтрокиДерева = НомерСтрокиДерева + 1;
	
	СтрокаДереваЗначений.НомерСтроки = НомерСтрокиДерева;	
	
	СоответствиеНомеровСтрокДерева.Вставить(НомерСтрокиДерева, СтрокаДереваЗначений);
	
КонецПроцедуры // ПрисвоитьУникальныйНомерСтрокеДерева()

// Добавляет новую строку в дерево сравнения.
// 
// Параметры:
//  Родитель - Строка дерева значений - родительская строка дерева.
//  ЭтоГруппа - Булево - признак группы.
//  ИмяУзла - Строка - имя узла.
//  ИндексКартинки - Число - индекс картинки табличной части.
//
// Возвращаемое значение:
//  СтрокаДереваЗначений - новая строка дерева.
//
Функция НовыйУзелДереваСравнения(Родитель, ЭтоГруппа, ИмяУзла = "", Путь, Представление = "", ИндексКартинки = -1)
	
	СтрокаДереваЗначений = Родитель.Строки.Добавить();
	
	ПрисвоитьУникальныйНомерСтрокеДерева(СтрокаДереваЗначений);
	
	СтрокаДереваЗначений.ЭтоГруппа		= ЭтоГруппа;
	СтрокаДереваЗначений.Путь			= Путь;
	СтрокаДереваЗначений.Представление	= Представление;
	
	Для каждого СтрокаТабличнойЧасти Из Конвертации Цикл
		
		Если НЕ ПустаяСтрока(ИмяУзла) Тогда
			
			СтрокаДереваЗначений["Колонка" + СтрокаТабличнойЧасти.НомерСтроки] = ИмяУзла;
			
		КонецЕсли;
		
		СтрокаДереваЗначений["ИндексКартинки" + СтрокаТабличнойЧасти.НомерСтроки] = ИндексКартинки;
		
		Если СтрокаТабличнойЧасти.НомерСтроки < Конвертации.Количество() Тогда
			
			СтрокаДереваЗначений["Различия" + СтрокаТабличнойЧасти.НомерСтроки] = Родитель["Различия" + СтрокаТабличнойЧасти.НомерСтроки];
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат СтрокаДереваЗначений;
	
КонецФункции // НовыйУзелДереваСравнения() 

// Создает строки дерева значений для хранения реквизитов, алгоритмов и параметров.
//
// Параметры:
//  СтрокаПравила - Строка дерева значений - родительская строка дерева.
//  ДобавитьУзелПараметров - Булево - признак необходимости добавить ветвь "Параметры".
//
// Возвращаемое значение:
//  Результат - Структура - структура, содержащая созданные узлы.
//
Функция НовыеУзлыРеквизитовДереваСравнения(СтрокаПравила, ЕстьОбработчики = Истина, ЕстьПараметры = Ложь)
	
	Результат = Новый Структура;
	Результат.Вставить("УзелРеквизиты", НовыйУзелДереваСравнения(СтрокаПравила, Истина,, "Реквизиты", "Реквизиты", 24));
	
	Если ЕстьОбработчики Тогда
	
		Результат.Вставить("УзелОбработчики", НовыйУзелДереваСравнения(СтрокаПравила, Истина,, "Алгоритмы",
			"Обработчики событий", 16));
	
	КонецЕсли;    
	
	Если ЕстьПараметры Тогда
		
		Результат.Вставить("УзелПараметры", НовыйУзелДереваСравнения(СтрокаПравила, Истина,, "Параметры",
			"Параметры", 47));
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // НовыеУзлыРеквизитовДереваСравнения()

// Создает таблицу значений для анализа тех реквизитов справочников, которые пользователь определил в форме настройки.
//
// Параметры:
//  ИмяСправочника - Строка - имя справочника, для которого необходимо получить таблицу реквизитов.
//
// Возвращаемое значение:
//  ТаблицаРеквизитов - Таблица значений, содержит перечень реквизитов, которые необходимо сравнить.
//
Функция НоваяТаблицаРеквизитов(ИмяСправочника)
	
	ТаблицаРеквизитов = Новый ТаблицаЗначений;
	ТаблицаРеквизитов.Колонки.Добавить("Путь");
	ТаблицаРеквизитов.Колонки.Добавить("Представление");
	ТаблицаРеквизитов.Колонки.Добавить("ЭтоАлгоритм", Новый ОписаниеТипов("Булево"));
	
	Для каждого Реквизит Из Метаданные.Справочники[ИмяСправочника].Реквизиты Цикл 
		
		Если НЕ НеобходимоСравнитьРеквизит(ИмяСправочника, Реквизит.Имя) Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		СтрокаТаблицы = ТаблицаРеквизитов.Добавить();
		
		ЭтоАлгоритм = Найти(Реквизит.Имя, "Алгоритм") > 0;
		
		ПредставлениеРеквизита = Реквизит.Синоним;
		
		Если ЭтоАлгоритм Тогда
			
			ПредставлениеРеквизита = СокрЛП(СтрЗаменить(Реквизит.Синоним, "Алгоритм", ""));
			ПредставлениеРеквизита = ВРег(Лев(ПредставлениеРеквизита, 1)) + Сред(ПредставлениеРеквизита, 2);
			
		КонецЕсли;
		
		СтрокаТаблицы.Путь			= Реквизит.Имя;
		СтрокаТаблицы.Представление	= ПредставлениеРеквизита;
		СтрокаТаблицы.ЭтоАлгоритм	= ЭтоАлгоритм;
		
	КонецЦикла;
	
	Возврат ТаблицаРеквизитов;
	
КонецФункции // НоваяТаблицаРеквизитов()

// Выполняет проверку необходимости сравнения реквизита справочника.
//
// Параметры:
//  ИмяСправочника - Строка - имя справочника.
//  Реквизит - Строка - имя реквизита.
// 
// Возвращаемое значение:
//  Булево - Истина, если значение реквизита должно сравниваться.
//
Функция НеобходимоСравнитьРеквизит(ИмяСправочника, Реквизит)
	
	СтруктураОтбор = Новый Структура("Справочник,Реквизит", ИмяСправочника, Реквизит);
	
	СтрокиОтбор = РеквизитыСравнения.НайтиСтроки(СтруктураОтбор);
	
	Если СтрокиОтбор.Количество() = 0 Тогда
		
		Возврат Ложь;
		
	Иначе
		
		Возврат СтрокиОтбор[0].Пометка;
		
	КонецЕсли;
	
КонецФункции // НеобходимоСравнитьРеквизит()

// Выполняет формирование структуры реквизитов, которые будут сравниваться.
//
Процедура ПодготовитьСравниваемыеРеквизиты()
	
	СравниваемыеРеквизиты = Новый Структура;
	СравниваемыеРеквизиты.Вставить("Конвертации"				, НоваяТаблицаРеквизитов("Конвертации"));
	СравниваемыеРеквизиты.Вставить("Параметры"					, НоваяТаблицаРеквизитов("Параметры"));
	СравниваемыеРеквизиты.Вставить("ПравилаКонвертацииОбъектов"	, НоваяТаблицаРеквизитов("ПравилаКонвертацииОбъектов"));
	СравниваемыеРеквизиты.Вставить("ПравилаКонвертацииСвойств"	, НоваяТаблицаРеквизитов("ПравилаКонвертацииСвойств"));
	СравниваемыеРеквизиты.Вставить("ПравилаВыгрузкиДанных"		, НоваяТаблицаРеквизитов("ПравилаВыгрузкиДанных"));
	СравниваемыеРеквизиты.Вставить("ПравилаОчисткиДанных"		, НоваяТаблицаРеквизитов("ПравилаОчисткиДанных"));
	СравниваемыеРеквизиты.Вставить("Алгоритмы"					, НоваяТаблицаРеквизитов("Алгоритмы"));
	СравниваемыеРеквизиты.Вставить("Запросы"					, НоваяТаблицаРеквизитов("Запросы"));
	
КонецПроцедуры // ПодготовитьСравниваемыеРеквизиты()

// Выполняет формирование узлов дерева по справочнику "Правила конвертации свойств".
//
// Параметры:
//  СтрокаДерева - Строка дерева значений - корневой узел вновь формируемых узлов.
//  ВыборкаПКО - Выборка из результата запроса - по справочнику "Правила конвертации объектов".
//  ВыборкаПКС - Выборка из результата запроса - по справочнику "Правила конвертации свойств".
//
Процедура СформироватьУзлыПКС(СтрокаДерева, ВыборкаПКО, ВыборкаПКС)
	
	Если ВыборкаПКС.НайтиСледующий(Новый Структура("ИмяВладельца", ВыборкаПКО.Имя)) Тогда
		
		УзелПКС = НовыйУзелДереваСравнения(СтрокаДерева, Истина,, "ГруппаПКС", "Правила конвертации свойств", 25);
		
		ВыборкаПоИмениРодителя = ВыборкаПКС.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
		
		Пока ВыборкаПоИмениРодителя.Следующий() Цикл
			
			// Узел родителя.
			
			Если ЗначениеЗаполнено(ВыборкаПоИмениРодителя.ИмяРодителя) Тогда
				
				Узел = УзелПКС.Строки.Добавить();
				
				ПрисвоитьУникальныйНомерСтрокеДерева(Узел);
				
				ВыборкаДетальная = ВыборкаПоИмениРодителя.Выбрать();
				
				Для каждого СтрокаТабличнойЧасти Из Конвертации Цикл
					
					НомерКолонки = СтрокаТабличнойЧасти.НомерСтроки;
					
					Узел["ИндексКартинки" + НомерКолонки] = 34;
					
					Если ВыборкаДетальная.НайтиСледующий(Новый Структура("Конвертация", СтрокаТабличнойЧасти.Конвертация)) Тогда
						
						Узел["Колонка" + НомерКолонки] = ВыборкаДетальная.Родитель;
						
						ВыборкаДетальная.Сбросить();
						
					КонецЕсли;	
					
				КонецЦикла;
				
				ВыполнитьСравнениеСтроки(Узел);
				
				УзлыРеквизитов = НовыеУзлыРеквизитовДереваСравнения(Узел); 
				
				ЗаполнитьУзлыРеквизитов(Узел, СравниваемыеРеквизиты["ПравилаКонвертацииСвойств"], УзлыРеквизитов);
				
				Узел.Путь = "ПГКС";
				
				// Подчиненный узел ПКС.
					
				Узел = НовыйУзелДереваСравнения(Узел, Истина,, "ГруппаПКС", "Правила конвертации свойств", 25);
				
			Иначе
				
				Узел = УзелПКС;
				
			КонецЕсли;  
			
			ВыборкаПоИмени = ВыборкаПоИмениРодителя.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
			
			Пока ВыборкаПоИмени.Следующий() Цикл
				
				СтрокаПравила = Узел.Строки.Добавить();
				
				ПрисвоитьУникальныйНомерСтрокеДерева(СтрокаПравила);
				
				ВыборкаДетальная = ВыборкаПоИмени.Выбрать();
				Пока ВыборкаДетальная.Следующий() Цикл
					
					СтрокаПравила["Колонка" + СоответствияПравил[ВыборкаДетальная.Конвертация]] = ВыборкаДетальная.Ссылка;
					
				КонецЦикла; 
				
				СтрокаПравила.Путь = "ПКС";
				
				УстановитьИндексКартинки(СтрокаПравила, 27); 
				
				ВыполнитьСравнениеСтроки(СтрокаПравила);
				
				УзлыРеквизитов = НовыеУзлыРеквизитовДереваСравнения(СтрокаПравила);
				
				ЗаполнитьУзлыРеквизитов(СтрокаПравила, СравниваемыеРеквизиты["ПравилаКонвертацииСвойств"], УзлыРеквизитов);
				
			КонецЦикла;
			
		КонецЦикла;
		
		ВыборкаПКС.Сбросить();
		
	КонецЕсли;
	
КонецПроцедуры // СформироватьУзлыПКС()

// Выполняет формирование узлов дерева по справочнику "Правила конвертации значений".
//
// Параметры:
//  СтрокаДерева - Строка дерева значений - корневой узел вновь формируемых узлов.
//  ВыборкаПКО - Выборка из результата запроса - по справочнику "Правила конвертации объектов".
//  ВыборкаПКЗ - Выборка из результата запроса - по справочнику "Правила конвертации значений".
//      
Процедура СформироватьУзлыПКЗ(СтрокаДерева, ВыборкаПКО, ВыборкаПКЗ)
	
	Если ВыборкаПКЗ.НайтиСледующий(Новый Структура("ИмяВладельца", ВыборкаПКО.Имя)) Тогда
		
		УзелПКЗ = НовыйУзелДереваСравнения(СтрокаДерева, Истина,, "ГруппаПКЗ", "Правила конвертации значений", 18);
		
		ВыборкаПоИмениРодителя = ВыборкаПКЗ.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
		
		Пока ВыборкаПоИмениРодителя.Следующий() Цикл
			
			Если ЗначениеЗаполнено(ВыборкаПоИмениРодителя.ИмяРодителя) Тогда
				
				УзелРодителя = УзелПКЗ.Строки.Добавить();
				
				ПрисвоитьУникальныйНомерСтрокеДерева(УзелРодителя);
				
				УзелРодителя.ЭтоГруппа = Истина;
				
				Для каждого СтрокаТабличнойЧасти Из Конвертации Цикл
					
					УзелРодителя["ИндексКартинки" + СтрокаТабличнойЧасти.НомерСтроки] = 34;
					УзелРодителя["Колонка" + СтрокаТабличнойЧасти.НомерСтроки] = ВыборкаПоИмениРодителя.ИмяРодителя;
					
				КонецЦикла;
				
				УзелРодителя.Путь = "Таблица";
				
			Иначе
				
				УзелРодителя = УзелПКЗ;
				
			КонецЕсли;
			
			ВыборкаПоИмени = ВыборкаПоИмениРодителя.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
			
			Пока ВыборкаПоИмени.Следующий() Цикл
				
				СтрокаПравила = УзелРодителя.Строки.Добавить();
				
				ПрисвоитьУникальныйНомерСтрокеДерева(СтрокаПравила);
				
				ВыборкаДетальная = ВыборкаПоИмени.Выбрать();
				Пока ВыборкаДетальная.Следующий() Цикл
					
					СтрокаПравила["Колонка" + СоответствияПравил[ВыборкаДетальная.Конвертация]] = ВыборкаДетальная.Ссылка;
					
				КонецЦикла;
				
				СтрокаПравила.Путь = "ПКЗ";
				
				УстановитьИндексКартинки(СтрокаПравила);
				
				ВыполнитьСравнениеСтроки(СтрокаПравила);
				
			КонецЦикла;
			
		КонецЦикла;
		
		ВыборкаПКЗ.Сбросить();
		
	КонецЕсли;
	
КонецПроцедуры // СформироватьУзлыПКЗ()

// Выполняет формирование строк общих реквизитов, заполняет их и производит
// сравнение.
//
// Параметры:
//  СтрокаДерева - Строка дерева значений.
//
Процедура ВыполнитьСравнениеОбщихРеквизитов(СтрокаДерева) 
	
	Если НЕ СравниватьОбщие Тогда
		
		Возврат;
		
	КонецЕсли;
	
	ТаблицаРеквизитов = СравниваемыеРеквизиты.Конвертации;
	
	УзлыРеквизитов = НовыеУзлыРеквизитовДереваСравнения(СтрокаДерева, Истина, Истина);	
	
	// Конвертации.
	
	Для каждого СтрокаТаблицы Из ТаблицаРеквизитов Цикл
		
		Если СтрокаТаблицы.Путь = "Код" Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		Если СтрокаТаблицы.ЭтоАлгоритм Тогда
			
			НоваяСтрока = УзлыРеквизитов.УзелОбработчики.Строки.Добавить();
			НоваяСтрока.Путь = "Алгоритм";
			НоваяСтрока.ВозможноОбъединение = Истина;
			
		Иначе
			
			НоваяСтрока = УзлыРеквизитов.УзелРеквизиты.Строки.Добавить();
			
		КонецЕсли;
		
		ПрисвоитьУникальныйНомерСтрокеДерева(НоваяСтрока);
		
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаТаблицы);
		
		Для каждого СтрокаТабличнойЧасти Из Конвертации Цикл
			
			НоваяСтрока["Колонка" + СтрокаТабличнойЧасти.НомерСтроки] = СтрокаТабличнойЧасти.Конвертация[СтрокаТаблицы.Путь]; 
			НоваяСтрока["ИндексКартинки" + СтрокаТабличнойЧасти.НомерСтроки] = ?(СтрокаТаблицы.ЭтоАлгоритм, 22, 26);
			
		КонецЦикла;
		
		ВыполнитьСравнениеСтроки(НоваяСтрока);
		
	КонецЦикла;
	
	СформироватьУзлыПравил("Параметры", УзлыРеквизитов.УзелПараметры);
	
КонецПроцедуры // ВыполнитьСравнениеОбщихРеквизитов() 

// Выполняет формирование строк правил конвертации объектов, правил конвертации свойств
// и правил конвертации значений, заполняет их и производит сравнение.
//
// Параметры:
//  СтрокаДерева - Строка дерева значений.
//
Процедура ВыполнитьСравнениеПравилКонвертацииОбъектов(СтрокаДерева) 
	
	Если СравниватьПравилаКонвертацииОбъектов Тогда
		
		ВыборкаПКС = СформироватьЗапросПоПКС();
		ВыборкаПКЗ = СформироватьЗапросПоПКЗ();
		
		СформироватьУзлыПравил("ПравилаКонвертацииОбъектов", СтрокаДерева, ВыборкаПКС, ВыборкаПКЗ);
		
	КонецЕсли;
	
КонецПроцедуры // ВыполнитьСравнениеПравилКонвертацииОбъектов() 

// Выполняет формирование строк правил выгрузки данных, заполняет их и производит сравнение.
//
// Параметры:
//  СтрокаДерева - Строка дерева значений.
//   
Процедура ВыполнитьСравнениеПравилВыгрузкиДанных(СтрокаДерева) 
	
	Если СравниватьПравилаВыгрузкиДанных Тогда
		
		СформироватьУзлыПравил("ПравилаВыгрузкиДанных", СтрокаДерева);
		
	КонецЕсли;
	
КонецПроцедуры // ВыполнитьСравнениеПравилВыгрузкиДанных()

// Выполняет формирование строк правил очистки данных, заполняет их и производит сравнение.
//
// Параметры:
//  СтрокаДерева - Строка дерева значений.
//  
Процедура ВыполнитьСравнениеПравилОчисткиДанных(СтрокаДерева) 
	
	Если СравниватьПравилаОчисткиДанных Тогда
		
		СформироватьУзлыПравил("ПравилаОчисткиДанных", СтрокаДерева);
		
	КонецЕсли;
	
КонецПроцедуры // ВыполнитьСравнениеПравилОчисткиДанных() 

// Выполняет формирование строк алгоритмов, заполняет их и производит сравнение.
//
// Параметры:
//  СтрокаДерева - Строка дерева значений.
//
Процедура ВыполнитьСравнениеАлгоритмов(СтрокаДерева) 
	
	Если СравниватьАлгоритмы Тогда
		
		СформироватьУзлыПравил("Алгоритмы", СтрокаДерева);
		
	КонецЕсли;
	
КонецПроцедуры // ВыполнитьСравнениеАлгоритмов() 

// Выполняет формирование строк запросов, заполняет их и производит сравнение.
//
// Параметры:
//  СтрокаДерева - Строка дерева значений.
//
Процедура ВыполнитьСравнениеЗапросов(СтрокаДерева) 
	
	Если СравниватьЗапросы Тогда
		
		СформироватьУзлыПравил("Запросы", СтрокаДерева);
		
	КонецЕсли;
	
КонецПроцедуры // ВыполнитьСравнениеЗапросов() 

// Выполняет сравнение и поиск различий в строке дерева сравнения и дерева значений -
// источника данных табличного поля ДеревоРезультатСравнения.
// 
// Параметры:
//  СтрокаДерева - Строка дерева значений - в которой будет выполнено сравнение.
//
Процедура ВыполнитьАнализСтрокиДерева(СтрокаДерева)
	
	Состояние(НСтр("ru = 'Выполняется поиск различий...'"));
	
	ВыполнитьСравнениеСтроки(СтрокаДерева);
	
	СтрокаДереваСравнения = СоответствиеНомеровСтрокДерева[СтрокаДерева.НомерСтроки];
	
	ЗаполнитьЗначенияСвойств(СтрокаДереваСравнения, СтрокаДерева); 
	
	Для каждого СтрокаПодчиненная Из СтрокаДерева.Строки Цикл
		
		ВыполнитьАнализСтрокиДерева(СтрокаПодчиненная);
		
	КонецЦикла;	
	
КонецПроцедуры // ВыполнитьАнализСтрокиДерева()

// Выполняет инициализацию процесса сравнения правил обмена.
//
Процедура ВыполнитьСравнениеПравилОбмена() 
	
	ПодготовитьСтруктуруДереваСравнения();
	
	НомерСтрокиДерева = 0;
	
	СоответствиеНомеровСтрокДерева = Новый Соответствие;
	
	КорневойУзелДерева = ДеревоСравнения.Строки.Добавить();
	
	ПрисвоитьУникальныйНомерСтрокеДерева(КорневойУзелДерева);
	
	КорневойУзелДерева.ЭтоГруппа = Истина;	
	
	Для каждого СтрокаТабличнойЧасти Из Конвертации Цикл
		
		КорневойУзелДерева["Колонка" + СтрокаТабличнойЧасти.НомерСтроки] = СтрокаТабличнойЧасти.Конвертация;
		КорневойУзелДерева["ИндексКартинки" + СтрокаТабличнойЧасти.НомерСтроки] = 0;
		
	КонецЦикла;
	
	УзелОбщие						= НовыйУзелДереваСравнения(КорневойУзелДерева, Истина, "Общие"							, "РазделОбщие"		,, 12);
	УзелПравилаКонвертацииОбъектов	= НовыйУзелДереваСравнения(КорневойУзелДерева, Истина, "Правила конвертации объектов"	, "РазделПКО"		,, 13);
	УзелПравилаВыгрузкиДанных		= НовыйУзелДереваСравнения(КорневойУзелДерева, Истина, "Правила выгрузки данных"		, "РазделПВД"		,, 14);
	УзелПравилаОчисткиДанных		= НовыйУзелДереваСравнения(КорневойУзелДерева, Истина, "Правила очистки данных"			, "РазделПОД"		,, 15);
	УзелАлгоритмы					= НовыйУзелДереваСравнения(КорневойУзелДерева, Истина, "Алгоритмы"						, "РазделАлгоритмы"	,, 16);
	УзелЗапросы						= НовыйУзелДереваСравнения(КорневойУзелДерева, Истина, "Запросы"						, "РазделЗапросы"	,, 17);
	
	ПодготовитьСравниваемыеРеквизиты();
	
	ВыполнитьСравнениеОбщихРеквизитов(УзелОбщие);
	ВыполнитьСравнениеПравилКонвертацииОбъектов(УзелПравилаКонвертацииОбъектов);
	ВыполнитьСравнениеПравилВыгрузкиДанных(УзелПравилаВыгрузкиДанных);
	ВыполнитьСравнениеПравилОчисткиДанных(УзелПравилаОчисткиДанных);
	ВыполнитьСравнениеАлгоритмов(УзелАлгоритмы);
	ВыполнитьСравнениеЗапросов(УзелЗапросы);  
	
КонецПроцедуры // ВыполнитьСравнениеПравилОбмена() 

///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ - ОБРАБОТЧИКИ СОБЫТИЙ ТАБЛИЧНОГО ПОЛЯ ДеревоРезультатСравнения 

Процедура ДеревоРезультатСравненияВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	
	ТекущиеДанные = ЭлементыФормы.ДеревоРезультатСравнения.ТекущиеДанные;
	
	Если ТекущиеДанные = Неопределено Тогда
		
		Возврат;
		
	КонецЕсли;
	
	ТекущаяКолонка = ЭлементыФормы.ДеревоРезультатСравнения.ТекущаяКолонка;
	
	ТекущееЗначение = ТекущиеДанные[ТекущаяКолонка.Имя];
	
	Если ЗначениеЗаполнено(ТекущееЗначение) 
		И ПоддерживаемыеТипы.Найти(ТипЗнч(ТекущееЗначение)) <> Неопределено Тогда
		
		ФормаЭлемента = ТекущееЗначение.ПолучитьФорму();
		ФормаЭлемента.Открыть();
		
	КонецЕсли;
	
КонецПроцедуры // ДеревоРезультатСравненияВыбор()

Процедура ДеревоРезультатСравненияПриАктивизацииСтроки(Элемент)

	УдалитьКнопкуКоманднойПанели("Разделитель");
	УдалитьКнопкуКоманднойПанели("СвернутьВсе");
	УдалитьКнопкуКоманднойПанели("РазвернутьВсе");
	УдалитьКнопкуКоманднойПанели("ПерейтиКПравилам");
	УдалитьКнопкуКоманднойПанели("ВыполнитьАнализРазличийСтроки");
	УдалитьКнопкуКоманднойПанели("Разделитель6");
	
	ТекущиеДанные = ЭлементыФормы.ДеревоРезультатСравнения.ТекущиеДанные;
	
	Если ТекущиеДанные = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	
	Если ТекущиеДанные.Строки.Количество() > 0 Тогда
		
		ДобавитьКнопкуКоманднойПанели("СвернутьВсе"  ,, НСтр("ru = 'Свернуть все'"), ТипКнопкиКоманднойПанели.Действие,
			Новый Действие("Подключаемый_КонтекстноеМенюСвернутьВсе"), БиблиотекаКартинок.СвернутьВсе);
			
		ДобавитьКнопкуКоманднойПанели("РазвернутьВсе",, НСтр("ru = 'Развернуть все'"), ТипКнопкиКоманднойПанели.Действие,
			Новый Действие("Подключаемый_КонтекстноеМенюРазвернутьВсе"), БиблиотекаКартинок.РазвернутьВсе);
			
		ДобавитьКнопкуКоманднойПанели("Разделитель",,, ТипКнопкиКоманднойПанели.Разделитель); 
		
	КонецЕсли;
	
	ДобавитьКнопкуКоманднойПанели("ВыполнитьАнализРазличийСтроки",, НСтр("ru = 'Найти различия'"), ТипКнопкиКоманднойПанели.Действие,
		Новый Действие("Подключаемый_КонтекстноеМенюВыполнитьПоискРазличийСтрокиДерева"), БиблиотекаКартинок.Сравнить);
		
	ДобавитьКнопкуКоманднойПанели("Разделитель6",,, ТипКнопкиКоманднойПанели.Разделитель); 
	
	МассивЗначений = Новый Массив;
	
	Для каждого СтрокаТабличнойЧасти Из Конвертации Цикл
		
		Значение = ТекущиеДанные["Колонка" + СтрокаТабличнойЧасти.НомерСтроки];
		
		Если Значение = Неопределено Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		МассивЗначений.Добавить(Значение);
		
	КонецЦикла;
	
	Для каждого Элемент Из МассивЗначений Цикл
		
		Если ПоддерживаемыеТипы.Найти(ТипЗнч(Элемент)) <> Неопределено Тогда
			
			ДобавитьКнопкуКоманднойПанели("ПерейтиКПравилам",, НСтр("ru = 'Перейти к правилам'"), ТипКнопкиКоманднойПанели.Действие,
				Новый Действие("Подключаемый_КонтекстноеМенюПерейтиКПравиламНажатие"), БиблиотекаКартинок.ЗначокНастройкаПараметровУчета16);
				
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Покажем значения в подвале.
	
	Для каждого СтрокаТабличнойЧасти Из Конвертации Цикл
		
		ИмяКолонки = "Колонка" + СтрокаТабличнойЧасти.НомерСтроки;
		
		Колонка = ЭлементыФормы.ДеревоРезультатСравнения.Колонки[ИмяКолонки];
		
		Значение = ТекущиеДанные[ИмяКолонки];
		
		Если ТипЗнч(Значение) = Тип("СправочникСсылка.Алгоритмы") Тогда
			
			Результат = Значение.Алгоритм;
			
		ИначеЕсли ТипЗнч(Значение) = Тип("СправочникСсылка.Запросы") Тогда
			
			Результат = Значение.ТекстЗапроса;
			
		ИначеЕсли ТипЗнч(Значение) = Тип("СправочникСсылка.ПравилаКонвертацииЗначений") Тогда
			
			Результат =
			"Источник: " + Строка(Значение.Источник) + "
			|Приемник: " + Строка(Значение.Приемник);
			
		Иначе
			
			Результат = Строка(Значение);
			
		КонецЕсли;
		
		Колонка.ТекстПодвала = Результат;
		
	КонецЦикла;
	
КонецПроцедуры // ДеревоРезультатСравненияПриАктивизацииСтроки()

Процедура ДеревоРезультатСравненияПриАктивизацииЯчейки(Элемент)
	
	// Удалим кнопки контекстного меню.
	
	УдалитьКнопкуКоманднойПанели("Разделитель1");
	УдалитьКнопкуКоманднойПанели("СравнитьСЛевым");
	УдалитьКнопкуКоманднойПанели("СравнитьСПравым");
	УдалитьКнопкуКоманднойПанели("СравнитьМодулиВыгрузкиСлева");
	УдалитьКнопкуКоманднойПанели("СравнитьМодулиВыгрузкиСправа");
	УдалитьКнопкуКоманднойПанели("СравнитьМодулиЗагрузкиСлева");
	УдалитьКнопкуКоманднойПанели("СравнитьМодулиЗагрузкиСправа");
	
	ТекущиеДанные = Элемент.ТекущиеДанные;
	
	Если ТекущиеДанные = Неопределено Тогда
		
		Возврат;
		
	КонецЕсли;
	
	ТекущаяКолонка = Элемент.ТекущаяКолонка;
	
	Если Найти(ТекущаяКолонка.Имя, "Колонка") = 0 Тогда
		Возврат;
	КонецЕсли;
	
	НомерКолонки = ОставитьТолькоЦифры(ТекущаяКолонка.Имя, Истина);
	
	Если НомерКолонки = 1 Тогда
		
		ДобавитьКнопкуКоманднойПанели("Разделитель1",,, ТипКнопкиКоманднойПанели.Разделитель);  
		
		Различие = ТекущиеДанные["Различия" + НомерКолонки];
		
		Если Различие = 2 Тогда
			
			ДобавитьКнопкуКоманднойПанели("СравнитьСПравым",, НСтр("ru = 'Показать различия'"), ТипКнопкиКоманднойПанели.Действие,
				Новый Действие("Подключаемый_КонтекстноеМенюСравнитьСПравымНажатие"), БиблиотекаКартинок.ПоказатьРазличия);
			
		КонецЕсли;
		
		Если ТекущиеДанные.Родитель = Неопределено Тогда
			
			Конвертация1 = ТекущиеДанные["Колонка" + НомерКолонки];
			Конвертация2 = ТекущиеДанные["Колонка" + (НомерКолонки + 1)];
			
			ДобавитьКнопкиСравненияМодулейВыгрузкиЗагрузки(Конвертация1, Конвертация2, "Справа");
			
		КонецЕсли;
		
	ИначеЕсли НомерКолонки = Конвертации.Количество() Тогда
		
		ДобавитьКнопкуКоманднойПанели("Разделитель1",,, ТипКнопкиКоманднойПанели.Разделитель);
		
		Различие = ТекущиеДанные["Различия" + (НомерКолонки -1)];
		
		Если Различие = 2 Тогда
			
			ДобавитьКнопкуКоманднойПанели("СравнитьСЛевым",, НСтр("ru = 'Показать различия'"), ТипКнопкиКоманднойПанели.Действие,
				Новый Действие("Подключаемый_КонтекстноеМенюСравнитьСЛевымНажатие") , БиблиотекаКартинок.ПоказатьРазличия);
			
		КонецЕсли;
		
		Если ТекущиеДанные.Родитель = Неопределено Тогда
			
			Конвертация1 = ТекущиеДанные["Колонка" + (НомерКолонки - 1)];
			Конвертация2 = ТекущиеДанные["Колонка" + НомерКолонки];
			
			ДобавитьКнопкиСравненияМодулейВыгрузкиЗагрузки(Конвертация1, Конвертация2, "Слева");
			
		КонецЕсли;
		
	Иначе
		
		РазличиеСлева = ТекущиеДанные["Различия" + (НомерКолонки -1)];
		РазличиеСправа = ТекущиеДанные["Различия" + НомерКолонки];
		
		Если РазличиеСлева = 2 Или РазличиеСлева = 2 Тогда
			ДобавитьКнопкуКоманднойПанели("Разделитель1",,, ТипКнопкиКоманднойПанели.Разделитель);
		КонецЕсли; 		
		
		Если РазличиеСлева = 2 Тогда
			
			ДобавитьКнопкуКоманднойПанели("СравнитьСЛевым",, НСтр("ru = 'Показать различия (с левым)'"), 
				ТипКнопкиКоманднойПанели.Действие, Новый Действие("Подключаемый_КонтекстноеМенюСравнитьСЛевымНажатие"),
				БиблиотекаКартинок.СравнитьСЛевым);
			
		КонецЕсли;
		
		Если РазличиеСправа = 2 Тогда
			
			ДобавитьКнопкуКоманднойПанели("СравнитьСПравым",, НСтр("ru = 'Показать различия (с правым)'"),
				ТипКнопкиКоманднойПанели.Действие, Новый Действие("Подключаемый_КонтекстноеМенюСравнитьСПравымНажатие"),
				БиблиотекаКартинок.СравнитьСПравым);
			
		КонецЕсли;
		
		Если ТекущиеДанные.Родитель = Неопределено Тогда
			
			ДобавитьКнопкиСравненияМодулейВыгрузкиЗагрузки(ТекущиеДанные["Колонка" + НомерКолонки],
				ТекущиеДанные["Колонка" + (НомерКолонки + 1)], "Справа", Истина);
			ДобавитьКнопкиСравненияМодулейВыгрузкиЗагрузки(ТекущиеДанные["Колонка" + (НомерКолонки -1)],
				ТекущиеДанные["Колонка" + НомерКолонки], "Слева", Истина);  
			
		КонецЕсли;
		
	КонецЕсли;
	
	ДеревоРезультатСравненияОбновитьКонтекстноеМеню();
	
КонецПроцедуры // ДеревоРезультатСравненияПриАктивизацииЯчейки()

Процедура ДеревоРезультатСравненияПриПолученииДанных(Элемент, ОформленияСтрок)
	
	СтруктураОтбор = Новый Структура("Пометка", Истина);
	
	ВыбранныеКонвертации = Конвертации.НайтиСтроки(СтруктураОтбор);
	
	КоличествоКолонокСравнения = Конвертации.Количество() - 1;
	
	СоответствиеРазличий = Новый Соответствие;
	СоответствиеРазличий.Вставить(0 , 8);	// Данные не изменились.
	СоответствиеРазличий.Вставить(-3, 9);	// Данные слева помечены на удаление, а данные справа - отсутствуют.
	СоответствиеРазличий.Вставить(-2, 8);	// Отсутствуют оба значения.
	СоответствиеРазличий.Вставить(-1, 9);	// Данные справа удалены.
	СоответствиеРазличий.Вставить(1	, 10);	// Данные справа добавлены.
	СоответствиеРазличий.Вставить(2	, 11);	// Данные различаются.
	
	КорневыеРазделы = Новый Массив;
	КорневыеРазделы.Добавить("РазделОбщие");
	КорневыеРазделы.Добавить("РазделПКО");
	КорневыеРазделы.Добавить("РазделПВД");
	КорневыеРазделы.Добавить("РазделПОД");
	КорневыеРазделы.Добавить("РазделАлгоритмы");
	КорневыеРазделы.Добавить("РазделЗапросы");
	
	Для каждого ОформлениеСтроки Из ОформленияСтрок Цикл
		
		ДанныеСтроки = ОформлениеСтроки.ДанныеСтроки;
		
		Для каждого СтрокаТабличнойЧасти Из ВыбранныеКонвертации Цикл
			
			Ячейка = ОформлениеСтроки.Ячейки["Колонка" + СтрокаТабличнойЧасти.НомерСтроки];
			
			Ячейка.ОтображатьФлажок	= Истина;
			Ячейка.Флажок			= ДанныеСтроки.Пометка;
			Ячейка.ЦветФона			= WebЦвета.Кремовый;
			
		КонецЦикла;
		
		Если ФильтрОтбора = 0 И ДанныеСтроки.Пометка > 0 Тогда 
			
			ОформлениеСтроки.Шрифт = Новый Шрифт(,, Истина);
			
		КонецЕсли;
		
		// Выведем пиктограммы сравнения.
		
		Для Ном = 1 По КоличествоКолонокСравнения Цикл
			
			ИмяКолонки = "Различия" + Ном;
			
			ИндексКартинки	= ДанныеСтроки[ИмяКолонки];
			ЕстьРазличия	= ДанныеСтроки["ЕстьРазличия" + Ном];
			
			Если (ДанныеСтроки.Родитель = Неопределено И ЕстьРазличия)
				ИЛИ (ИндексКартинки = 0 И ЕстьРазличия И КорневыеРазделы.Найти(ДанныеСтроки.Путь) = Неопределено) Тогда
				
				ИндексКартинки = 11;
				
			ИначеЕсли ДанныеСтроки.Родитель <> Неопределено 
				И ДанныеСтроки.Родитель.ЭтоГруппа 
				И КорневыеРазделы.Найти(ДанныеСтроки.Путь) <> Неопределено Тогда
				
				ИндексКартинки = -1;  
				
			Иначе
				
				ИндексКартинки = СоответствиеРазличий[ИндексКартинки];
				
			КонецЕсли;
			
			Если ИндексКартинки >= 0 Тогда
				
				ОформлениеСтроки.Ячейки[ИмяКолонки].ИндексКартинки = ИндексКартинки;
				ОформлениеСтроки.Ячейки[ИмяКолонки].ОтображатьКартинку = Истина;
				
			КонецЕсли;
		
		КонецЦикла;
		
		// Оформим табличное поле недостающими данными.
		
		КоличествоКонвертаций = Конвертации.Количество();
		
		Для каждого СтрокаТабличнойЧасти Из Конвертации Цикл
			
			ИмяКолонки = "Колонка" + СтрокаТабличнойЧасти.НомерСтроки;
			
			ИндексКартинки = ДанныеСтроки["ИндексКартинки" + СтрокаТабличнойЧасти.НомерСтроки];
			
			// Переопределим пиктограммы помеченных на удаление объектов.
			
			Значение = ДанныеСтроки[ИмяКолонки];
			
			Если ЗначениеЗаполнено(Значение) Тогда
				
				Если ПоддерживаемыеТипы.Найти(ТипЗнч(Значение)) <> Неопределено Тогда
					
					Если Значение.ПометкаУдаления Тогда
						
						Если Значение.ЭтоГруппа Тогда
							
							ИндексКартинки = 2;
							
						Иначе
							
							Если ИндексКартинки = 26 Тогда
								
								ИндексКартинки = 28;
								
							ИначеЕсли ИндексКартинки = 27 Тогда
								
								ИндексКартинки = 29;
								
							Иначе
								
								ИндексКартинки = 4;
								
							КонецЕсли;
							
						КонецЕсли;
						
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЕсли;
			
			Если ИндексКартинки >= 0 Тогда
				
				ОформлениеСтроки.Ячейки[ИмяКолонки].ИндексКартинки = ИндексКартинки;
				ОформлениеСтроки.Ячейки[ИмяКолонки].ОтображатьКартинку = Истина;
				
			КонецЕсли;			
			
			ИмяКолонкиРазличий = "Различия" + ?(СтрокаТабличнойЧасти.НомерСтроки = КоличествоКонвертаций,
				(СтрокаТабличнойЧасти.НомерСтроки - 1), СтрокаТабличнойЧасти.НомерСтроки);   
			
			Если СтрокаТабличнойЧасти.НомерСтроки = КоличествоКонвертаций Тогда
				
				ДанныеИзменены = (ДанныеСтроки[ИмяКолонкиРазличий] = -2) ИЛИ (ДанныеСтроки[ИмяКолонкиРазличий] = -1); 
				
			Иначе
				
				ДанныеИзменены = (ДанныеСтроки[ИмяКолонкиРазличий] = -2) ИЛИ (ДанныеСтроки[ИмяКолонкиРазличий] = 1);
				
			КонецЕсли;			
			
			Если ДанныеИзменены Тогда
				
				Если (ВыбранныеКонвертации.Количество() = 0 И КоличествоКонвертаций = 2 И СтрокаТабличнойЧасти.НомерСтроки = 1) 
					ИЛИ ВыбранныеКонвертации.Найти(СтрокаТабличнойЧасти) <> Неопределено Тогда
					
					ОформлениеСтроки.Ячейки[ИмяКолонки].ЦветФона = WebЦвета.БледноМиндальный;
					
				Иначе
					
					ОформлениеСтроки.Ячейки[ИмяКолонки].ЦветФона = WebЦвета.НейтральноЗеленый;
					
				КонецЕсли;  
				
			КонецЕсли;
					
			Если НЕ ЗначениеЗаполнено(Значение)
				И (НЕ ЗначениеЗаполнено(ДанныеСтроки.Представление)
				ИЛИ ПримитивныеТипы.Найти(ТипЗнч(Значение)) = Неопределено) Тогда
				
				ОформлениеСтроки.Ячейки[ИмяКолонки].УстановитьТекст("<Отсутствует>");   			
				
			Иначе
				
				Если ЗначениеЗаполнено(ДанныеСтроки.Представление) Тогда
					
					ОформлениеСтроки.Ячейки[ИмяКолонки].УстановитьТекст(ДанныеСтроки.Представление);
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры // ДеревоРезультатСравненияПриПолученииДанных()

Процедура ДеревоРезультатСравненияПриИзмененииФлажка(Элемент, Колонка)
	
	ТекущиеДанные = ЭлементыФормы.ДеревоРезультатСравнения.ТекущиеДанные;
	
	ТекущиеДанные.Пометка = ?(ТекущиеДанные.Пометка = 1, 0, 1);
	
	УстановитьФлажки(ТекущиеДанные, ТекущиеДанные.Пометка);
	
	УстановитьПометкуРодителя(ТекущиеДанные); 
	
	ДеревоРезультатСравненияОбновитьКонтекстноеМеню();
	
КонецПроцедуры // ДеревоРезультатСравненияПриИзмененииФлажка()

///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ - ОБРАБОТЧИКИ РЕКВИЗИТОВ ФОРМЫ 

Процедура ФильтрОтбораПриИзменении(Элемент)
	
	Если ТекущийФильтрОтбора <> ФильтрОтбора Тогда
		
		ТекущийФильтрОтбора = ФильтрОтбора;
		
		СформироватьДеревоРезультатСравнения();
		
	КонецЕсли;
	
КонецПроцедуры // ФильтрОтбораПриИзменении() 

Процедура ПолосаРегулированияПодвалПриИзменении(Элемент)
	
	УстановитьВидимость();
	
КонецПроцедуры // ПолосаРегулированияПодвалПриИзменении

///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ - ОБРАБОТЧИКИ СОБЫТИЙ КОМАНДНОЙ ПАНЕЛИ КонтекстноеМеню

Процедура Подключаемый_КонтекстноеМенюСвернутьВсе(Кнопка)
	
	ТекущиеДанные = ЭлементыФормы.ДеревоРезультатСравнения.ТекущиеДанные;
	
	Если ТекущиеДанные = Неопределено Тогда
		
		Возврат;
		
	КонецЕсли;
	
	РазвернутьСвернутьСтрокуДерева(ТекущиеДанные, Истина);
	
КонецПроцедуры // Подключаемый_КонтекстноеМенюСвернутьВсе()

Процедура Подключаемый_КонтекстноеМенюРазвернутьВсе(Кнопка)
	
	ТекущиеДанные = ЭлементыФормы.ДеревоРезультатСравнения.ТекущиеДанные;
	
	Если ТекущиеДанные = Неопределено Тогда
		
		Возврат;
		
	КонецЕсли;
	
	РазвернутьСвернутьСтрокуДерева(ТекущиеДанные);
	
КонецПроцедуры // Подключаемый_КонтекстноеМенюРазвернутьВсе()

Процедура Подключаемый_КонтекстноеМенюВыполнитьПоискРазличийСтрокиДерева()
	
	ТекущиеДанные = ЭлементыФормы.ДеревоРезультатСравнения.ТекущиеДанные;
	
	Если ТекущиеДанные = Неопределено Тогда
		
		Возврат;
		
	КонецЕсли;
	
	НайтиОтличияВСтрокеДерева(ТекущиеДанные);
	
КонецПроцедуры // Подключаемый_КонтекстноеМенюВыполнитьПоискРазличийСтрокиДерева()

Процедура Подключаемый_КонтекстноеМенюПерейтиКПравиламНажатие(Кнопка)
	
	ТекущиеДанные = ЭлементыФормы.ДеревоРезультатСравнения.ТекущиеДанные;
	
	Если ТекущиеДанные = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ТекущаяКолонка = ЭлементыФормы.ДеревоРезультатСравнения.ТекущаяКолонка.Имя;
	
	ТекущаяКонвертация	= ДеревоРезультатСравнения.Строки[0][ТекущаяКолонка];
	ТекущаяСсылка		= ТекущиеДанные[ТекущаяКолонка];

	Если НЕ ЗначениеЗаполнено(ТекущаяСсылка) Тогда
		
		Возврат;
		
	КонецЕсли;
	
	// Перейти на правило в форме настройки.
	
	ФормаПравилОбмена = ПолучитьОбщуюФорму("ПравилаОбмена",, 1);
	ФормаПравилОбмена.Конвертация = ТекущаяКонвертация;
	
	ТекущаяСтраница = "";
	
	Если ТипЗнч(ТекущаяСсылка) = Тип("СправочникСсылка.Конвертации") Тогда
		
		ФормаПравилОбмена.Конвертация = ТекущаяКонвертация;

	ИначеЕсли ТипЗнч(ТекущаяСсылка) = Тип("СправочникСсылка.ПравилаКонвертацииЗначений") Тогда
		
		ТекущаяСтраница = "ПКО";
		
		ФормаПравилОбмена.ЭлементыФормы.ПравилаКонвертацииОбъектов.ТекущаяСтрока = ТекущаяСсылка.Владелец;
		ФормаПравилОбмена.ЭлементыФормы.ПравилаКонвертацииЗначений.ТекущаяСтрока = ТекущаяСсылка;
		
	ИначеЕсли ТипЗнч(ТекущаяСсылка) = Тип("СправочникСсылка.ПравилаКонвертацииСвойств") Тогда
		
		ТекущаяСтраница = "ПКО";
		
		ФормаПравилОбмена.ЭлементыФормы.ПравилаКонвертацииОбъектов.ТекущаяСтрока = ТекущаяСсылка.Владелец;
		ФормаПравилОбмена.ЭлементыФормы.ПравилаКонвертацииСвойств.ТекущаяСтрока = ТекущаяСсылка;
		
	ИначеЕсли ТипЗнч(ТекущаяСсылка) = Тип("СправочникСсылка.ПравилаКонвертацииОбъектов") Тогда
		
		ТекущаяСтраница = "ПКО";
		
		ФормаПравилОбмена.ЭлементыФормы.ПравилаКонвертацииОбъектов.ТекущаяСтрока = ТекущаяСсылка;
		
	ИначеЕсли ТипЗнч(ТекущаяСсылка) = Тип("СправочникСсылка.ПравилаВыгрузкиДанных") Тогда
		
		ТекущаяСтраница = "ПВД";
		ФормаПравилОбмена.ЭлементыФормы.ПравилаВыгрузкиДанных.ТекущаяСтрока = ТекущаяСсылка;
		
	ИначеЕсли ТипЗнч(ТекущаяСсылка) = Тип("СправочникСсылка.ПравилаОчисткиДанных") Тогда
		
		ТекущаяСтраница = "ПОД";
		ФормаПравилОбмена.ЭлементыФормы.ПравилаОчисткиДанных.ТекущаяСтрока = ТекущаяСсылка;
		
	ИначеЕсли ТипЗнч(ТекущаяСсылка) = Тип("СправочникСсылка.Алгоритмы") Тогда
		
		ТекущаяСтраница = "АлгоритмыЗапросы";	
		ФормаПравилОбмена.ЭлементыФормы.Алгоритмы.ТекущаяСтрока = ТекущаяСсылка;
		
	ИначеЕсли ТипЗнч(ТекущаяСсылка) = Тип("СправочникСсылка.Запросы") Тогда
		
		ТекущаяСтраница = "АлгоритмыЗапросы";
		ФормаПравилОбмена.ЭлементыФормы.Запросы.ТекущаяСтрока = ТекущаяСсылка;
		
	Иначе
		
		Возврат;
		
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ТекущаяСтраница) Тогда
		
		ФормаПравилОбмена.ЭлементыФормы.ПанельВерхняя.ТекущаяСтраница = ФормаПравилОбмена.ЭлементыФормы.ПанельВерхняя.Страницы[ТекущаяСтраница];
		
	КонецЕсли;
	
	ФормаПравилОбмена.Открыть();
	
КонецПроцедуры // Подключаемый_КонтекстноеМенюПерейтиКПравиламНажатие()

Процедура Подключаемый_КонтекстноеМенюСравнитьСЛевымНажатие(Кнопка)
	
	ВыполнитьАнализРазличийФайлов(, -1, 0);
	
КонецПроцедуры // Подключаемый_КонтекстноеМенюСравнитьСЛевымНажатие()

Процедура Подключаемый_КонтекстноеМенюСравнитьСПравымНажатие(Кнопка)
	
	ВыполнитьАнализРазличийФайлов(, 0, 1);
	
КонецПроцедуры // Подключаемый_КонтекстноеМенюСравнитьСПравымНажатие()

Процедура Подключаемый_КонтекстноеМенюСравнитьМодулиВыгрузкиСлева(Кнопка)
	
	ВыполнитьАнализРазличийФайлов("СравнениеМодулейВыгрузки", -1, 0);

КонецПроцедуры // Подключаемый_КонтекстноеМенюСравнитьМодулиВыгрузкиСлева()

Процедура Подключаемый_КонтекстноеМенюСравнитьМодулиВыгрузкиСправа(Кнопка)
	
	ВыполнитьАнализРазличийФайлов("СравнениеМодулейВыгрузки", 0, 1);
	
КонецПроцедуры // Подключаемый_КонтекстноеМенюСравнитьМодулиВыгрузкиСправа()

Процедура Подключаемый_КонтекстноеМенюСравнитьМодулиЗагрузкиСлева(Кнопка)
	
	ВыполнитьАнализРазличийФайлов("СравнениеМодулейЗагрузки", -1, 0);
	
КонецПроцедуры // Подключаемый_КонтекстноеМенюСравнитьМодулиЗагрузкиСлева()

Процедура Подключаемый_КонтекстноеМенюСравнитьМодулиЗагрузкиСправа(Кнопка)
	
	ВыполнитьАнализРазличийФайлов("СравнениеМодулейЗагрузки", 0, 1);
	
КонецПроцедуры // Подключаемый_КонтекстноеМенюСравнитьМодулиЗагрузкиСправа()

Процедура Подключаемый_КонтекстноеМенюВзятьИзЛевогоНажатие(Кнопка)
	
	Если НЕ ОбъединениеПодтверждено() Тогда
		
		Возврат;
		
	КонецЕсли;	

	ТекущиеДанные = ЭлементыФормы.ДеревоРезультатСравнения.ТекущиеДанные;
	ТекущаяКолонка = ЭлементыФормы.ДеревоРезультатСравнения.ТекущаяКолонка;
	
	НомерКолонки = ОставитьТолькоЦифры(ТекущаяКолонка.Имя, Истина);  
	
	КолонкаИсточник		= "Колонка" + (НомерКолонки - 1);
	КолонкаПриемник		= ТекущаяКолонка.Имя;
	КолонкаРазличия		= "Различия" + (НомерКолонки - 1);
	КолонкаЕстьРазличия	= "ЕстьРазличия" + (НомерКолонки - 1);
	
	ВыполнитьОбъединениеПравил(ТекущиеДанные, КолонкаИсточник, КолонкаПриемник, КолонкаРазличия, КолонкаЕстьРазличия); 
	
	НайтиОтличияВСтрокеДерева(ТекущиеДанные);
	
КонецПроцедуры // Подключаемый_КонтекстноеМенюВзятьИзЛевогоНажатие()

Процедура Подключаемый_КонтекстноеМенюОбъединитьСЛевымНажатие(Кнопка)
	
	Если НЕ ОбъединениеПодтверждено() Тогда
		
		Возврат;
		
	КонецЕсли;	
	
	ТекущиеДанные = ЭлементыФормы.ДеревоРезультатСравнения.ТекущиеДанные;
	ТекущаяКолонка = ЭлементыФормы.ДеревоРезультатСравнения.ТекущаяКолонка;
	
	НомерКолонки = ОставитьТолькоЦифры(ТекущаяКолонка.Имя, Истина);  
	
	КолонкаИсточник = "Колонка" + (НомерКолонки - 1);
	КолонкаПриемник = ТекущаяКолонка.Имя;
	
	ВыполнитьОбъединениеПравилKDiff3(ТекущиеДанные, КолонкаИсточник, КолонкаПриемник); 
	
	НайтиОтличияВСтрокеДерева(ТекущиеДанные);
	
КонецПроцедуры // Подключаемый_КонтекстноеМенюОбъединитьСЛевымНажатие()

Процедура Подключаемый_КонтекстноеМенюВзятьИзПравогоНажатие(Кнопка)
	
	Если НЕ ОбъединениеПодтверждено() Тогда
		
		Возврат;
		
	КонецЕсли;	
	
	ТекущиеДанные = ЭлементыФормы.ДеревоРезультатСравнения.ТекущиеДанные;
	ТекущаяКолонка = ЭлементыФормы.ДеревоРезультатСравнения.ТекущаяКолонка;    
	
	НомерКолонки = ОставитьТолькоЦифры(ТекущаяКолонка.Имя, Истина);
	
	КолонкаИсточник		= "Колонка" + (НомерКолонки + 1);
	КолонкаПриемник		= ТекущаяКолонка.Имя;
	КолонкаРазличия		= "Различия" + НомерКолонки;
	КолонкаЕстьРазличия = "ЕстьРазличия" + НомерКолонки;
	
	ВыполнитьОбъединениеПравил(ТекущиеДанные, КолонкаИсточник, КолонкаПриемник, КолонкаРазличия, КолонкаЕстьРазличия); 
	
	НайтиОтличияВСтрокеДерева(ТекущиеДанные);
	
КонецПроцедуры // Подключаемый_КонтекстноеМенюВзятьИзПравогоНажатие()

Процедура Подключаемый_КонтекстноеМенюОбъединитьСПравымНажатие(Кнопка)
	
	Если НЕ ОбъединениеПодтверждено() Тогда
		
		Возврат;
		
	КонецЕсли;	
	
	ТекущиеДанные = ЭлементыФормы.ДеревоРезультатСравнения.ТекущиеДанные;
	ТекущаяКолонка = ЭлементыФормы.ДеревоРезультатСравнения.ТекущаяКолонка;  

	НомерКолонки = ОставитьТолькоЦифры(ТекущаяКолонка.Имя, Истина);
	
	КолонкаИсточник = "Колонка" + (НомерКолонки + 1);
	КолонкаПриемник = ТекущаяКолонка.Имя;
	
	ВыполнитьОбъединениеПравилKDiff3(ТекущиеДанные, КолонкаИсточник, КолонкаПриемник); 
	
	НайтиОтличияВСтрокеДерева(ТекущиеДанные);
	
КонецПроцедуры // Подключаемый_КонтекстноеМенюОбъединитьСПравымНажатие()

///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ - ОБРАБОТЧИКИ КОМАНДНОЙ ПАНЕЛИ ОсновныеДействияФормы. 

Процедура ОсновныеДействияФормыСформировать(Кнопка)
	
	Если Конвертации.Количество() = 0 Тогда
		
		Предупреждение(НСтр("ru = 'Не выбраны правила обмена!'"));
		Возврат;
		
	КонецЕсли;
	
	Если Конвертации.Количество() < 2 Тогда
		
		Предупреждение(НСтр("ru = 'Для сравнения должно быть выбрано не менее двух правила обмена!'"));
		Возврат;
		
	КонецЕсли;
	
	Если Конвертации.Найти(Справочники.Конвертации.ПустаяСсылка(), "Конвертация") <> Неопределено Тогда
		
		Предупреждение(НСтр("ru = 'Обнаружены строки с пустыми правилами обмена!'"));
		Возврат;
		
	КонецЕсли;
	
	Если ДеревоРезультатСравнения.Строки.Количество() > 0 Тогда
		
		Ответ = Вопрос(НСтр("ru = 'Дерево сравнения правил обмена будет очищено. Продолжить?'"), РежимДиалогаВопрос.ДаНет,,
			КодВозвратаДиалога.Да);
		
		Если Ответ = КодВозвратаДиалога.Нет Тогда
				
			Возврат;
			
		КонецЕсли;
		
	КонецЕсли;
	
	ВыполнитьСравнениеПравилОбмена();
	
	СформироватьДеревоРезультатСравнения();
	
КонецПроцедуры // ОсновныеДействияФормыСформировать()

Процедура ОсновныеДействияФормыПечать(Кнопка)
	
	ТабличныйДокумент = Новый ТабличныйДокумент;
	
	Макет = ПолучитьМакет("ОтчетОСравненииПравил");
	
	ОбластьЗаголовок	= Макет.ПолучитьОбласть("Заголовок");
	ОбластьШапка		= Макет.ПолучитьОбласть("Шапка|Колонка");
	ОбластьНачалоСтроки	= Макет.ПолучитьОбласть("Строка|ПустаяКолонка");
	ОбластьГруппа		= Макет.ПолучитьОбласть("Группа|Колонка");
	ОбластьСтрока		= Макет.ПолучитьОбласть("Строка|Колонка");
	
	ОбластьЗаголовок.Параметры.Параметры = "Текущее значение фильтра: " + ?(ФильтрОтбора = 0, "Показывать все",
		?(ФильтрОтбора = 1, "Показывать измененные", "Показывать добавленные и удаленные"));
	
	ТабличныйДокумент.Вывести(ОбластьЗаголовок);
	
	Область = Макет.ПолучитьОбласть("Шапка|ПустаяКолонка");
	ТабличныйДокумент.Вывести(Область);
	
	Для каждого СтрокаТабличнойЧасти Из Конвертации Цикл
		
		ОбластьШапка.Параметры.ПравилоКонвертации = СтрокаТабличнойЧасти.Конвертация;
		ТабличныйДокумент.Присоединить(ОбластьШапка);
		
	КонецЦикла;
	
	Уровень = 0;
	
	ТабличныйДокумент.НачатьАвтогруппировкуСтрок();
	
	Для каждого СтрокаДерева Из ДеревоРезультатСравнения.Строки Цикл
		
		ВывестиСтрокиРекурсивно(Уровень, ТабличныйДокумент, ОбластьНачалоСтроки, ОбластьГруппа, ОбластьСтрока, СтрокаДерева);
		
	КонецЦикла;	
	
	ТабличныйДокумент.ЗакончитьАвтогруппировкуСтрок();
	
	ТабличныйДокумент.ТолькоПросмотр		= Истина;
	ТабличныйДокумент.ОтображатьЗаголовки	= Ложь;
	ТабличныйДокумент.ОтображатьСетку		= Ложь;
	ТабличныйДокумент.ОриентацияСтраницы	= ОриентацияСтраницы.Ландшафт;
	
	ТабличныйДокумент.ПоказатьУровеньГруппировокСтрок(2);
	
	ТабличныйДокумент.Показать("Отчет о сравнении");

КонецПроцедуры // ОсновныеДействияФормыПечать()

Процедура ОсновныеДействияФормыНастройка(Кнопка)
	
	ОткрытьФормуНастройки("ОбщиеНастройки");
	
КонецПроцедуры // ОсновныеДействияФормыНастройка() 

Процедура ОсновныеДействияФормыПодвал(Кнопка)
	
	ИспользоватьПодвалДляАнализа = НЕ ИспользоватьПодвалДляАнализа;
	
	УстановитьВидимость();
	
КонецПроцедуры // ОсновныеДействияФормыПодвал()

Процедура ОсновныеДействияФормыВыполнить(Кнопка)
	
	Если НЕ ОбъединениеПодтверждено() Тогда
		
		Возврат;
		
	КонецЕсли;
	
	ТекущиеДанные = ДеревоРезультатСравнения.Строки[0];
	ТекущаяКолонка = ДеревоРезультатСравнения.Колонки.Колонка1;
	
	НомерКолонки = ОставитьТолькоЦифры(ТекущаяКолонка.Имя, Истина);
	
	КолонкаИсточник		= "Колонка" + (НомерКолонки + 1);
	КолонкаПриемник		= ТекущаяКолонка.Имя;
	КолонкаРазличия		= "Различия" + НомерКолонки;
	КолонкаЕстьРазличия = "ЕстьРазличия" + НомерКолонки;
	
	ВыполнитьОбъединениеПравил(ТекущиеДанные, КолонкаИсточник, КолонкаПриемник, КолонкаРазличия, КолонкаЕстьРазличия); 
	
	Предупреждение(Нстр("ru = 'Объединение правил обмена завершено.'"));
	
	ЭтаФорма.Закрыть();
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ - ОБРАБОТЧИКИ СОБЫТИЙ ФОРМЫ

Процедура ПриОткрытии()
	
	ФильтрОтбора = ВосстановитьЗначение("СравнениеИОбъединениеПравилОбмена.ФильтрОтбора");
	
	ТекущийФильтрОтбора = ФильтрОтбора;
	
	ВысотаПодвала = ВосстановитьЗначение("СравнениеИОбъединениеПравилОбмена.ВысотаПодвала");  
	
	ВосстановитьЗначениеБулево(СравниватьОбщие							, "СравнениеИОбъединениеПравилОбмена.СравниватьОбщие");
	ВосстановитьЗначениеБулево(СравниватьПравилаКонвертацииОбъектов		, "СравнениеИОбъединениеПравилОбмена.СравниватьПравилаКонвертацииОбъектов");
	ВосстановитьЗначениеБулево(СравниватьПравилаКонвертацииСвойств		, "СравнениеИОбъединениеПравилОбмена.СравниватьПравилаКонвертацииСвойств");
	ВосстановитьЗначениеБулево(СравниватьПравилаКонвертацииСвойствПоКоду, "СравнениеИОбъединениеПравилОбмена.СравниватьПравилаКонвертацииСвойствПоКоду");
	ВосстановитьЗначениеБулево(СравниватьПравилаКонвертацииЗначений		, "СравнениеИОбъединениеПравилОбмена.СравниватьПравилаКонвертацииЗначений");
	ВосстановитьЗначениеБулево(СравниватьПравилаВыгрузкиДанных			, "СравнениеИОбъединениеПравилОбмена.СравниватьПравилаВыгрузкиДанных");
	ВосстановитьЗначениеБулево(СравниватьПравилаОчисткиДанных			, "СравнениеИОбъединениеПравилОбмена.СравниватьПравилаОчисткиДанных");
	ВосстановитьЗначениеБулево(СравниватьАлгоритмы						, "СравнениеИОбъединениеПравилОбмена.СравниватьАлгоритмы");
	ВосстановитьЗначениеБулево(СравниватьЗапросы						, "СравнениеИОбъединениеПравилОбмена.СравниватьЗапросы");
	ВосстановитьЗначениеБулево(СравниватьПорядокВыполнения				, "СравнениеИОбъединениеПравилОбмена.СравниватьПорядокВыполнения", Ложь);   
	ВосстановитьЗначениеБулево(СравниватьСсылкиПоПредставлению			, "СравнениеИОбъединениеПравилОбмена.СравниватьСсылкиПоПредставлению");
	ВосстановитьЗначениеБулево(СравниватьПомеченныеНаУдаление			, "СравнениеИОбъединениеПравилОбмена.СравниватьПомеченныеНаУдаление");
	ВосстановитьЗначениеБулево(ОпределятьТипКартинкиПоИсточнику			, "СравнениеИОбъединениеПравилОбмена.ОпределятьТипКартинкиПоИсточнику", Ложь);
	ВосстановитьЗначениеБулево(ИспользоватьПодвалДляАнализа				, "СравнениеИОбъединениеПравилОбмена.ИспользоватьПодвалДляАнализа", Ложь);
	ВосстановитьЗначениеБулево(ТребоватьПодтвержденияПередОбъединением	, "СравнениеИОбъединениеПравилОбмена.ТребоватьПодтвержденияПередОбъединением");	
	
	ВосстановитьЗначениеБулево(ИспользоватьKDiff3ДляОбъединенияМодулей, "СравнениеИОбъединениеПравилОбмена.ИспользоватьKDiff3ДляОбъединенияМодулей", Ложь);
	ИсполняемыйФайлKDiff3 = ВосстановитьЗначение("СравнениеИОбъединениеПравилОбмена.ИсполняемыйФайлKDiff3");
	
	ПроверитьАктуальностьПравилОбмена();
	
	ЗаполнитьТаблицуРеквизитовСравнения();
	
	УстановитьВидимость();
	
	ВыполнитьСравнениеПравилОбмена();
	
	СформироватьДеревоРезультатСравнения();
	
	СохранитьЗначение("СравнениеИОбъединениеПравилОбмена." + Конвертации[0].Конвертация.Код, Конвертации[1].Конвертация);
	
КонецПроцедуры // ПриОткрытии()

Процедура ПриЗакрытии()
	
	СохранитьЗначение("СравнениеИОбъединениеПравилОбмена.СравниватьОбщие"							, СравниватьОбщие);
	СохранитьЗначение("СравнениеИОбъединениеПравилОбмена.СравниватьПравилаКонвертацииОбъектов"		, СравниватьПравилаКонвертацииОбъектов);
	СохранитьЗначение("СравнениеИОбъединениеПравилОбмена.СравниватьПравилаКонвертацииСвойств"		, СравниватьПравилаКонвертацииСвойств);
	СохранитьЗначение("СравнениеИОбъединениеПравилОбмена.СравниватьПравилаКонвертацииСвойствПоКоду"	, СравниватьПравилаКонвертацииСвойствПоКоду);
	СохранитьЗначение("СравнениеИОбъединениеПравилОбмена.СравниватьПравилаКонвертацииЗначений"		, СравниватьПравилаКонвертацииЗначений);
	СохранитьЗначение("СравнениеИОбъединениеПравилОбмена.СравниватьПравилаВыгрузкиДанных"			, СравниватьПравилаВыгрузкиДанных);
	СохранитьЗначение("СравнениеИОбъединениеПравилОбмена.СравниватьПравилаОчисткиДанных"			, СравниватьПравилаОчисткиДанных);
	СохранитьЗначение("СравнениеИОбъединениеПравилОбмена.СравниватьАлгоритмы"						, СравниватьАлгоритмы);
	СохранитьЗначение("СравнениеИОбъединениеПравилОбмена.СравниватьЗапросы"							, СравниватьЗапросы);
	СохранитьЗначение("СравнениеИОбъединениеПравилОбмена.СравниватьПорядокВыполнения"				, СравниватьПорядокВыполнения);
	СохранитьЗначение("СравнениеИОбъединениеПравилОбмена.СравниватьСсылкиПоПредставлению"			, СравниватьСсылкиПоПредставлению);
	СохранитьЗначение("СравнениеИОбъединениеПравилОбмена.СравниватьПомеченныеНаУдаление"			, СравниватьПомеченныеНаУдаление);
	СохранитьЗначение("СравнениеИОбъединениеПравилОбмена.ОпределятьТипКартинкиПоИсточнику"			, ОпределятьТипКартинкиПоИсточнику);
	СохранитьЗначение("СравнениеИОбъединениеПравилОбмена.ИспользоватьПодвалДляАнализа"				, ИспользоватьПодвалДляАнализа);
	СохранитьЗначение("СравнениеИОбъединениеПравилОбмена.ФильтрОтбора"								, ФильтрОтбора);
	СохранитьЗначение("СравнениеИОбъединениеПравилОбмена.ВысотаПодвала"								, ВысотаПодвала);
	СохранитьЗначение("СравнениеИОбъединениеПравилОбмена.ТребоватьПодтвержденияПередОбъединением"	, ТребоватьПодтвержденияПередОбъединением);
	СохранитьЗначение("СравнениеИОбъединениеПравилОбмена.ИспользоватьKDiff3ДляОбъединенияМодулей"	, ИспользоватьKDiff3ДляОбъединенияМодулей);
	СохранитьЗначение("СравнениеИОбъединениеПравилОбмена.ИсполняемыйФайлKDiff3"						, ИсполняемыйФайлKDiff3);
	СохранитьЗначение("СравнениеИОбъединениеПравилОбмена.РеквизитыСравнения", РеквизитыСравнения.Выгрузить());
	
КонецПроцедуры // ПриЗакрытии()

Процедура ОбработкаОповещения(ИмяСобытия, Параметр, Источник)
	
	Если ИмяСобытия = "ОбновитьПравилаОбмена" Тогда	
		
		ПодготовитьСтруктуруДереваСравнения();
		
		СформироватьДеревоРезультатСравнения();
		
		УстановитьВидимость();
		
	ИначеЕсли ИмяСобытия = "УстановитьВидимость" Тогда
		
		УстановитьВидимость();
		
	КонецЕсли;
	
КонецПроцедуры // ОбработкаОповещения()

Процедура ПередОткрытием(Отказ, СтандартнаяОбработка)
	
	ПоследняяКонвертация = ВосстановитьЗначение("СравнениеИОбъединениеПравилОбмена." + Конвертации[0].Конвертация.Код);
	
	ФормаВыбора = Справочники.Конвертации.ПолучитьФормуВыбора();
	ФормаВыбора.Заголовок = Нстр("ru = 'Выберите конвертацию для сравнения'");
	ФормаВыбора.НачальноеЗначениеВыбора = ПоследняяКонвертация;
	ФормаВыбора.ЗакрыватьПриВыборе = Истина;
	КонвертацияДляСравнения = ФормаВыбора.ОткрытьМодально();
	
	Если КонвертацияДляСравнения = Неопределено Тогда
		ЭтаФорма.Закрыть();
	КонецЕсли;
	
	Если Конвертации[0].Конвертация = КонвертацияДляСравнения Тогда
		Предупреждение(Нстр("ru = 'Сравнение конвертации с собой недопустимо.'"));
		ЭтаФорма.Закрыть();
	КонецЕсли;
	
	Конвертации[0].Пометка = Истина;
	
	НоваяСтрока = Конвертации.Добавить();
	НоваяСтрока.Конвертация = КонвертацияДляСравнения;
	НоваяСтрока.Пометка = Ложь;
	
КонецПроцедуры

Процедура ПередЗакрытием(Отказ, СтандартнаяОбработка)
	
	Ответ = Вопрос("Закрыть окно сравнения и объединения правил обмена?", РежимДиалогаВопрос.ДаНет);
	
	Если Ответ = КодВозвратаДиалога.Нет Тогда
		
		Отказ = Истина;
		
	КонецЕсли;
	
КонецПроцедуры

///////////////////////////////////////////////////////////////////////////////
// ОСНОВНОЙ ТЕКСТ МОДУЛЯ 

ПримитивныеТипы = Новый Массив;
ПримитивныеТипы.Добавить(Тип("Число"));
ПримитивныеТипы.Добавить(Тип("Строка"));
ПримитивныеТипы.Добавить(Тип("Дата"));
ПримитивныеТипы.Добавить(Тип("Булево"));
ПримитивныеТипы.Добавить(Тип("Неопределено"));
ПримитивныеТипы.Добавить(Тип("NULL"));

ПоддерживаемыеТипы = Новый Массив;
ПоддерживаемыеТипы.Добавить(Тип("СправочникСсылка.Конвертации"));
ПоддерживаемыеТипы.Добавить(Тип("СправочникСсылка.Параметры"));
ПоддерживаемыеТипы.Добавить(Тип("СправочникСсылка.ПравилаКонвертацииЗначений"));
ПоддерживаемыеТипы.Добавить(Тип("СправочникСсылка.ПравилаКонвертацииСвойств"));
ПоддерживаемыеТипы.Добавить(Тип("СправочникСсылка.ПравилаКонвертацииОбъектов"));
ПоддерживаемыеТипы.Добавить(Тип("СправочникСсылка.ПравилаВыгрузкиДанных"));
ПоддерживаемыеТипы.Добавить(Тип("СправочникСсылка.ПравилаОчисткиДанных"));
ПоддерживаемыеТипы.Добавить(Тип("СправочникСсылка.Алгоритмы"));
ПоддерживаемыеТипы.Добавить(Тип("СправочникСсылка.Запросы"));
ПоддерживаемыеТипы.Добавить(Тип("СправочникСсылка.Объекты"));
ПоддерживаемыеТипы.Добавить(Тип("СправочникСсылка.Значения"));